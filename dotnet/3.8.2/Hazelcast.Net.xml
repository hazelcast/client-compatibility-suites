<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Hazelcast.Net</name>
    </assembly>
    <members>
        <member name="M:Hazelcast.Client.Connection.ClientConnectionManager.GetOrConnect(Hazelcast.IO.Address,Hazelcast.Util.Authenticator)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.Client.Connection.ClientConnectionManager.GetConnection(Hazelcast.IO.Address)">
            <summary>
            Gets an existing connection for the given address
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:Hazelcast.Client.Connection.ClientConnectionManager.GetOrConnect(Hazelcast.IO.Address)">
            <summary>
            Gets the connection for the address. If there is no connection, a new one will be created
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Hazelcast.Client.Connection.ClientConnectionManager.CheckLive">
            <exception cref="T:Hazelcast.Core.HazelcastException"></exception>
        </member>
        <member name="T:Hazelcast.Client.Connection.ClientConnection">
            <summary>Holds the clientSocket to one of the members of Hazelcast ICluster. SSL encription is used if configured.</summary>
        </member>
        <member name="M:Hazelcast.Client.Connection.ClientConnection.#ctor(Hazelcast.Client.Connection.ClientConnectionManager,Hazelcast.Client.Spi.ClientInvocationService,System.Int32,Hazelcast.IO.Address,Hazelcast.Config.ClientNetworkConfig)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.Client.Connection.ClientConnection.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.Client.Connection.ClientConnection.Init(Hazelcast.IO.ISocketInterceptor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.Client.Connection.DefaultSocketFactory.CreateSocket">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.Client.Connection.ISocketFactory.CreateSocket">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.Client.Protocol.Util.BufferBuilder">
            <summary>Builder for appending buffers that grows capacity as necessary.</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.Util.BufferBuilder.InitialCapacity">
            <summary>Buffer's default initial capacity</summary>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.BufferBuilder.#ctor">
            <summary>
                Construct a buffer builder with a default growth increment of
                <see cref="F:Hazelcast.Client.Protocol.Util.BufferBuilder.InitialCapacity" />
            </summary>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.BufferBuilder.#ctor(System.Int32)">
            <summary>Construct a buffer builder with an initial capacity that will be rounded up to the nearest power of 2.</summary>
            <param name="initialCapacity">at which the capacity will start.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.BufferBuilder.Append(Hazelcast.Client.Protocol.Util.IClientProtocolBuffer,System.Int32,System.Int32)">
            <summary>Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.</summary>
            <param name="srcBuffer">from which to copy.</param>
            <param name="srcOffset">in the source buffer from which to copy.</param>
            <param name="length">in bytes to copy from the source buffer.</param>
            <returns>the builder for fluent API usage.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.BufferBuilder.Buffer">
            <summary>
                The
                <see cref="T:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer" />
                that encapsulates the internal buffer.
            </summary>
            <returns>
                the
                <see cref="T:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer" />
                that encapsulates the internal buffer.
            </returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.BufferBuilder.Capacity">
            <summary>The current capacity of the buffer.</summary>
            <returns>the current capacity of the buffer.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.BufferBuilder.Position">
            <summary>The current position of the buffer that has been used by accumulate operations.</summary>
            <returns>the current position of the buffer that has been used by accumulate operations.</returns>
        </member>
        <member name="T:Hazelcast.Client.Protocol.Util.ClientMessageBuilder">
            <summary>
                Builds
                <see cref="T:Hazelcast.Client.Protocol.ClientMessage" />
                s from byte chunks. Fragmented messages are merged into single messages before processed.
            </summary>
        </member>
        <member name="T:Hazelcast.Client.Protocol.Util.ClientMessageBuilder.HandleMessageDelegate">
            <summary>Implementers will be responsible to delegate the constructed message</summary>
        </member>
        <member name="T:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer">
            <summary>Interface for buffer to be used in client protocol.</summary>
            <remarks>
                Interface for buffer to be used in client protocol.
                Implemented by
                <see cref="T:Hazelcast.Client.Protocol.Util.SafeBuffer" />
            </remarks>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.ByteArray">
            <summary>Get the underlying byte[] if one exists.</summary>
            <returns>the underlying byte[] if one exists.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.Capacity">
            <summary>Get the capacity of the underlying buffer.</summary>
            <returns>the capacity of the underlying buffer in bytes.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.GetByte(System.Int32)">
            <summary>Get the value at a given index.</summary>
            <param name="index">in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.GetBytes(System.Int32,System.Byte[])">
            <summary>Get from the underlying buffer into a supplied byte array.</summary>
            <remarks>
                Get from the underlying buffer into a supplied byte array.
                This method will try to fill the supplied byte array.
            </remarks>
            <param name="index">in the underlying buffer to start from.</param>
            <param name="dst">into which the dst will be copied.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.GetBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Get bytes from the underlying buffer into a supplied byte array.</summary>
            <param name="index">in the underlying buffer to start from.</param>
            <param name="dst">into which the bytes will be copied.</param>
            <param name="offset">in the supplied buffer to start the copy</param>
            <param name="length">of the supplied buffer to use.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.GetInt(System.Int32)">
            <summary>Get the value at a given index.</summary>
            <param name="index">in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.GetLong(System.Int32)">
            <summary>Get the value at a given index.</summary>
            <param name="index">in bytes from which to get.</param>
            <returns>the value for at a given index</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.GetShort(System.Int32)">
            <summary>Get the value at a given index.</summary>
            <param name="index">in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.GetStringUtf8(System.Int32,System.Int32)">
            <summary>Get part of String from bytes encoded in UTF-8 format without a length prefix.</summary>
            <param name="offset">at which the String begins.</param>
            <param name="length">of the String in bytes to decode.</param>
            <returns>the String as represented by the UTF-8 encoded bytes.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.PutByte(System.Int32,System.Byte)">
            <summary>Put a value to a given index.</summary>
            <param name="index">The index in bytes where the value is put.</param>
            <param name="value">The value put at the given index.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.PutBytes(System.Int32,System.Byte[])">
            <summary>Put an array of src into the underlying buffer.</summary>
            <param name="index">The index in the underlying buffer from which to start the array.</param>
            <param name="src">The array to be copied into the underlying buffer.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.PutBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Put an array into the underlying buffer.</summary>
            <param name="index">The index in the underlying buffer from which to start the array.</param>
            <param name="src">The array to be copied into the underlying buffer.</param>
            <param name="offset">The offset in the supplied buffer at which to begin the copy.</param>
            <param name="length">The length of the supplied buffer to copy.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.PutInt(System.Int32,System.Int32)">
            <summary>Put a value at a given index.</summary>
            <param name="index">The index in bytes where the value is put.</param>
            <param name="value">The value put at the given index.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.PutLong(System.Int32,System.Int64)">
            <summary>Put a value at a given index.</summary>
            <param name="index">The index in bytes where the value is put.</param>
            <param name="value">The value to put at the given index.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.PutShort(System.Int32,System.Int16)">
            <summary>Put a value to a given index.</summary>
            <param name="index">The index in bytes where the value is put.</param>
            <param name="value">The value put at the given index.</param>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.PutStringUtf8(System.Int32,System.String)">
            <summary>Encode a String as UTF-8 bytes to the buffer with a length prefix.</summary>
            <param name="index">The index at which the String should be encoded.</param>
            <param name="value">The value of the String to be encoded.</param>
            <returns>The number of bytes put to the buffer.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.PutStringUtf8(System.Int32,System.String,System.Int32)">
            <summary>Encode a String as UTF-8 bytes the buffer with a length prefix with a maximum encoded size check.</summary>
            <param name="index">The index at which the String should be encoded.</param>
            <param name="value">The value of the String to be encoded.</param>
            <param name="maxEncodedSize">The maximum encoded size to be checked before writing to the buffer.</param>
            <returns>The number of bytes put to the buffer.</returns>
            <exception cref="T:System.ArgumentException">if the encoded bytes are greater than maxEncodedSize.</exception>
        </member>
        <member name="M:Hazelcast.Client.Protocol.Util.IClientProtocolBuffer.Wrap(System.Byte[])">
            <summary>Attach a view to a byte[] for providing direct access.</summary>
            <param name="buffer">to which the view is attached.</param>
        </member>
        <member name="T:Hazelcast.Client.Protocol.Util.MessageFlyweight">
            <summary>Parameter Flyweight</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.Util.MessageFlyweight.LongMask">
            <summary>Long mask</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.Util.MessageFlyweight.IntMask">
            <summary>Int mask</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.Util.MessageFlyweight.ShortMask">
            <summary>Short mask</summary>
        </member>
        <member name="T:Hazelcast.Client.Protocol.Util.SafeBuffer">
            <summary>Implementation of IClientProtocolBuffer that is used by default in clients.</summary>
            <remarks>
                Implementation of IClientProtocolBuffer that is used by default in clients.
                There is another unsafe implementation which is configurable .
            </remarks>
        </member>
        <member name="T:Hazelcast.Client.Protocol.ClientMessage">
            <summary>
                Client Message is the carrier framed data as defined below.
            </summary>
            <remarks>
                <p>
                    Client Message is the carrier framed data as defined below.
                </p>
                <p>
                    Any request parameter, response or event data will be carried in
                    the payload.
                </p>
                <p />
                <pre>
                    0                   1                   2                   3
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                    |R|                      Frame Length                           |
                    +-------------+---------------+---------------------------------+
                    |  Version    |B|E|  Flags    |               Type              |
                    +-------------+---------------+---------------------------------+
                    |                                                               |
                    +                       CorrelationId                           +
                    |                                                               |
                    +---------------------------------------------------------------+
                    |                        PartitionId                            |
                    +-----------------------------+---------------------------------+
                    |        Data Offset          |                                 |
                    +-----------------------------+                                 |
                    |                      Message Payload Data                    ...
                    |                                                              ...
                </pre>
            </remarks>
        </member>
        <member name="F:Hazelcast.Client.Protocol.ClientMessage.Version">
            <summary>Current protocol version</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.ClientMessage.BeginFlag">
            <summary>Begin Flag</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.ClientMessage.EndFlag">
            <summary>End Flag</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.ClientMessage.BeginAndEndFlags">
            <summary>Begin and End Flags</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.ClientMessage.ListenerEventFlag">
            <summary>Listener Event Flag</summary>
        </member>
        <member name="F:Hazelcast.Client.Protocol.ClientMessage.HeaderSize">
            <summary>ClientMessage Fixed Header size in bytes</summary>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.IsFlagSet(System.Int16)">
            <param name="flag">Check this flag to see if it is set.</param>
            <returns>true if the given flag is set, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.AddFlag(System.Int16)">
            <summary>Sets the flags field value.</summary>
            <param name="flags">The value to set in the flags field.</param>
            <returns>The ClientMessage with the new flags field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.GetMessageType">
            <summary>Returns the message type field.</summary>
            <returns>The message type field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.GetCorrelationId">
            <summary>Returns the correlation id field.</summary>
            <returns>The correlation id field.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.SetCorrelationId(System.Int64)">
            <summary>Sets the correlation id field.</summary>
            <param name="correlationId">The value to set in the correlation id field.</param>
            <returns>The ClientMessage with the new correlation id field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.GetPartitionId">
            <summary>Returns the partition id field.</summary>
            <returns>The partition id field.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.SetPartitionId(System.Int32)">
            <summary>Sets the partition id field.</summary>
            <param name="partitionId">The value to set in the partitions id field.</param>
            <returns>The ClientMessage with the new partitions id field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.GetDataOffset">
            <summary>Returns the setDataOffset field.</summary>
            <returns>The setDataOffset type field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.GetFlags">
            <summary>Returns the flags field value.</summary>
            <returns>The flags field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.GetFrameLength">
            <summary>Returns the frame length field.</summary>
            <returns>The frame length field.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.GetVersion">
            <summary>Returns the version field value.</summary>
            <returns>The version field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.IsComplete">
            <summary>Checks the frame size and total data size to validate the message size.</summary>
            <returns>true if the message is constructed.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.SetDataOffset(System.Int32)">
            <summary>Sets the dataOffset field.</summary>
            <param name="dataOffset">The value to set in the dataOffset field.</param>
            <returns>The ClientMessage with the new dataOffset field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.SetFrameLength(System.Int32)">
            <summary>Sets the frame length field.</summary>
            <param name="length">The value to set in the frame length field.</param>
            <returns>The ClientMessage with the new frame length field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.SetMessageType(System.Int32)">
            <summary>Sets the message type field.</summary>
            <param name="type">The value to set in the message type field.</param>
            <returns>The ClientMessage with the new message type field value.</returns>
        </member>
        <member name="M:Hazelcast.Client.Protocol.ClientMessage.SetVersion(System.Int16)">
            <summary>Sets the version field value.</summary>
            <param name="version">The value to set in the version field.</param>
            <returns>The ClientMessage with the new version field value.</returns>
        </member>
        <member name="T:Hazelcast.Client.Protocol.ClientProtocolErrorCodes">
            <summary>Each exception that are defined in client protocol have unique identifier which are error code.</summary>
            <remarks>
                Each exception that are defined in client protocol have unique identifier which are error code.
                All error codes defined in protocol are listed in this class.
            </remarks>
        </member>
        <member name="T:Hazelcast.Client.Protocol.EventMessageConst">
            <summary>Message type ids of event responses in client protocol.</summary>
            <remarks>
                Message type ids of event responses in client protocol. They also used to bind a request to event inside Request
                annotation.
            </remarks>
        </member>
        <member name="M:Hazelcast.Client.Protocol.IClientMessage.SetCorrelationId(System.Int64)">
            <summary>Sets the correlation id field.</summary>
            <param name="correlationId">The value to set in the correlation id field.</param>
            <returns>The ClientMessage with the new correlation id field value.</returns>
        </member>
        <member name="T:Hazelcast.Client.Protocol.ResponseMessageConst">
            <summary>Message type ids of responses in client protocol.</summary>
            <remarks>
                Message type ids of responses in client protocol. They also used to bind a request to a response inside Request
                annotation.
            </remarks>
        </member>
        <member name="F:Hazelcast.Client.Proxy.ClientRingbufferProxy`1.MaxBatchSize">
            <summary>
                The maximum number of items that can be retrieved in 1 go using the  <see cref="M:Hazelcast.Core.IRingbuffer`1.ReadManyAsync(System.Int64,System.Int32,System.Int32)" />
                method.
            </summary>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientCountDownLatchProxy.Await(System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientLockProxy.TryLock(System.Int64,System.Nullable{Hazelcast.Core.TimeUnit})">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientMapProxy`2.TryLock(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientMapProxy`2.TryLock(`0,System.Int64,Hazelcast.Core.TimeUnit,System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientMultiMapProxy`2.TryLock(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientMultiMapProxy`2.TryLock(`0,System.Int64,Hazelcast.Core.TimeUnit,System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientSemaphoreProxy.Acquire">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientSemaphoreProxy.Acquire(System.Int32)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientSemaphoreProxy.TryAcquire(System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientSemaphoreProxy.TryAcquire(System.Int32,System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientTxnMultiMapProxy`2.Put(`0,`1)">
            <exception cref="T:Hazelcast.Transaction.TransactionException"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientTxnQueueProxy`1.Offer(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientTxnQueueProxy`1.Poll(System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.ClientTxnQueueProxy`1.Peek(System.Int64,Hazelcast.Core.TimeUnit)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Client.Proxy.TransactionContextProxy.CommitTransaction">
            <exception cref="T:Hazelcast.Transaction.TransactionException"></exception>
        </member>
        <member name="P:Hazelcast.Client.Spi.ClientInvocation.SentConnection">
            <summary>
            Connection that was used to execute this invocation
            </summary>
        </member>
        <member name="T:Hazelcast.Client.Spi.MemberAttributeOperationType">
            <summary>Used to identify the type of member attribute change, either PUT or REMOVED</summary>
        </member>
        <member name="M:Hazelcast.Client.Spi.ClientMembershipListener.WaitInitialMemberListFetched">
            <exception cref="T:System.Exception" />
        </member>
        <member name="T:Hazelcast.Client.Spi.ClientClusterService">
            <summary>
                The
                <see cref="T:Hazelcast.Client.Spi.ClientClusterService" />
                implementation.
            </summary>
        </member>
        <member name="M:Hazelcast.Client.Spi.ClientClusterService.Start">
            <exception cref="T:System.Exception" />
        </member>
        <member name="M:Hazelcast.Client.Spi.ClientClusterService.Connect(System.Collections.Generic.ICollection{System.Net.IPEndPoint})">
            <exception cref="T:System.Exception" />
        </member>
        <member name="T:Hazelcast.Client.Spi.IClientClusterService">
            <author>mdogan 5/16/13</author>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.AddMembershipListener(Hazelcast.Core.IMembershipListener)">
            <param name="listener">The listener to be registered.</param>
            <returns>The registration id.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.GetClusterTime">
            <summary>Returns the cluster-time.</summary>
            <remarks>
            Returns the cluster-time.
            <p/>
            </remarks>
            <returns>The cluster-time.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.GetLocalClient">
            <returns>The client interface representing the local client.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.GetMasterAddress">
            <summary>Returns the address of the master member.</summary>
            <returns>The address of the master member. Could be null if the master is not yet known.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.GetMember(Hazelcast.IO.Address)">
            <summary>Gets the member for the given address.</summary>
            <param name="address">The address of the member to look up.</param>
            <returns>The member that was found, or null if not found. If address is null, null is returned.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.GetMember(System.String)">
            <summary>Gets the member with the given uuid.</summary>
            <param name="uuid">The uuid of the member.</param>
            <returns>The member that was found, or null if not found. If uuid is null, null is returned.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.GetMemberList">
            <summary>Gets the collection of members.</summary>
            <returns>The collection of members. Null will never be returned.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.GetOwnerConnectionAddress">
            <summary>The owner connection is opened to owner member of the client in the cluster.</summary>
            <remarks>
            The owner connection is opened to owner member of the client in the cluster.
            If the owner member dies, other members of the cluster assumes this client is dead.
            </remarks>
            <returns>The address of the owner connection.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.GetSize">
            <summary>Gets the current number of members.</summary>
            <returns>The current number of members.</returns>
        </member>
        <member name="M:Hazelcast.Client.Spi.IClientClusterService.RemoveMembershipListener(System.String)">
            <param name="registrationId">The registrationId of the listener to be removed.</param>
            <returns>true if successfully removed, false otherwise.</returns>
        </member>
        <member name="T:Hazelcast.Client.Spi.IClientInvocationService">
            <summary>
                invocation service
            </summary>
        </member>
        <member name="F:Hazelcast.Client.Error.Type">
            <summary>ClientMessageType of this message</summary>
        </member>
        <member name="T:Hazelcast.Client.HazelcastClient">
            <summary>
                Hazelcast Client enables you to do all Hazelcast operations without
                being a member of the cluster.
            </summary>
            <remarks>
                Hazelcast Client enables you to do all Hazelcast operations without
                being a member of the cluster. It connects to one of the
                cluster members and delegates all cluster wide operations to it.
                When the connected cluster member dies, client will
                automatically switch to another live member.
            </remarks>
        </member>
        <member name="M:Hazelcast.Client.HazelcastClient.GetAllHazelcastClients">
            <summary>
                Gets all Hazelcast clients.
            </summary>
            <returns>ICollection&lt;IHazelcastInstance&gt;</returns>
        </member>
        <member name="M:Hazelcast.Client.HazelcastClient.NewHazelcastClient">
            <summary>
                Creates a new hazelcast client using default configuration.
            </summary>
            <remarks>
                Creates a new hazelcast client using default configuration.
            </remarks>
            <returns>IHazelcastInstance.</returns>
            <example>
                <code>
                var hazelcastInstance = Hazelcast.NewHazelcastClient();
                var myMap = hazelcastInstance.GetMap("myMap");
            </code>
            </example>
        </member>
        <member name="M:Hazelcast.Client.HazelcastClient.NewHazelcastClient(System.String)">
            <summary>
                Creates a new hazelcast client using the given configuration xml file
            </summary>
            <param name="configFile">The configuration file with full or relative path.</param>
            <returns>IHazelcastInstance.</returns>
            <example>
                <code>
                //Full path
                var hazelcastInstance = Hazelcast.NewHazelcastClient(@"C:\Users\user\Hazelcast.Net\hazelcast-client.xml");
                var myMap = hazelcastInstance.GetMap("myMap");
                
                //relative path
                var hazelcastInstance = Hazelcast.NewHazelcastClient(@"..\Hazelcast.Net\Resources\hazelcast-client.xml");
                var myMap = hazelcastInstance.GetMap("myMap");
            </code>
            </example>
        </member>
        <member name="M:Hazelcast.Client.HazelcastClient.NewHazelcastClient(Hazelcast.Config.ClientConfig)">
            <summary>
                Creates a new hazelcast client using the given configuration object created programmaticly.
            </summary>
            <param name="config">The configuration.</param>
            <returns>IHazelcastInstance.</returns>
            <code>
                var clientConfig = new ClientConfig();
                //configure clientConfig ...
                var hazelcastInstance = Hazelcast.NewHazelcastClient(clientConfig);
                var myMap = hazelcastInstance.GetMap("myMap");
            </code>
        </member>
        <member name="M:Hazelcast.Client.HazelcastClient.ShutdownAll">
            <summary>
                Shutdowns all Hazelcast Clients .
            </summary>
        </member>
        <member name="T:Hazelcast.Client.ILoadBalancer">
            <summary>
                <see cref="T:Hazelcast.Client.ILoadBalancer">ILoadBalancer</see>
                allows you to send operations to one of a number of endpoints(Members).
                It is up to the implementation to use different load balancing policies. If IClient is
                <see cref="M:Hazelcast.Config.ClientNetworkConfig.SetSmartRouting(System.Boolean)">is in smart routing mode</see>
                ,
                only the operations that are not key based will be router to the endpoint returned by the Load Balancer.
                If it is not
                <see cref="M:Hazelcast.Config.ClientNetworkConfig.SetSmartRouting(System.Boolean)">in smart routing mode</see>
                ,
                <see cref="T:Hazelcast.Client.ILoadBalancer">ILoadBalancer</see>
                will not be used.
            </summary>
        </member>
        <member name="M:Hazelcast.Client.ILoadBalancer.Next">
            <summary>Returns the next member to route to</summary>
            <returns>Returns the next member or null if no member is available</returns>
        </member>
        <member name="F:Hazelcast.Config.ClientNetworkConfig._addressList">
            <summary>List of the initial set of addresses.</summary>
            <remarks>
            List of the initial set of addresses.
            Client will use this list to find a running Member, connect to it.
            </remarks>
        </member>
        <member name="F:Hazelcast.Config.ClientNetworkConfig._connectionAttemptLimit">
            <summary>
            While client is trying to connect initially to one of the members in the
            <see cref="F:Hazelcast.Config.ClientNetworkConfig._addressList">addressList</see>
            ,
            all might be not available. Instead of giving up, throwing Exception and stopping client, it will
            attempt to retry as much as
            <see cref="F:Hazelcast.Config.ClientNetworkConfig._connectionAttemptLimit">connectionAttemptLimit</see>
            times.
            </summary>
        </member>
        <member name="F:Hazelcast.Config.ClientNetworkConfig._connectionAttemptPeriod">
            <summary>Period for the next attempt to find a member to connect.</summary>
            <remarks>
            Period for the next attempt to find a member to connect. (see
            <see cref="F:Hazelcast.Config.ClientNetworkConfig._connectionAttemptLimit">connectionAttemptLimit</see>
            ).
            </remarks>
        </member>
        <member name="F:Hazelcast.Config.ClientNetworkConfig._connectionTimeout">
            <summary>Timeout value in millis for nodes to accept client connection requests</summary>
            <remarks>
            Timeout value in millis for nodes to accept client connection requests
            </remarks>
        </member>
        <member name="F:Hazelcast.Config.ClientNetworkConfig._redoOperation">
            <summary>If true, client will redo the operations that were executing on the server and client lost the connection.</summary>
            <remarks>
            If true, client will redo the operations that were executing on the server and client lost the connection.
            This can be because of network, or simply because the member died. However it is not clear whether the
            application is performed or not. For idempotent operations this is harmless, but for non idempotent ones
            retrying can cause to undesirable effects. Note that the redo can perform on any member.
            <p/>
            </remarks>
        </member>
        <member name="F:Hazelcast.Config.ClientNetworkConfig._smartRouting">
            <summary>If true, client will route the key based operations to owner of the key at the best effort.</summary>
            <remarks>
            If true, client will route the key based operations to owner of the key at the best effort.
            Note that it  doesn't guarantee that the operation will always be executed on the owner. The cached table is updated every 10 seconds.
            </remarks>
        </member>
        <member name="F:Hazelcast.Config.ClientNetworkConfig._socketInterceptorConfig">
            <summary>Will be called with the Socket, each time client creates a connection to any Member.</summary>
            <remarks>Will be called with the Socket, each time client creates a connection to any Member.</remarks>
        </member>
        <member name="F:Hazelcast.Config.ClientNetworkConfig._socketOptions">
            <summary>Options for creating socket</summary>
        </member>
        <member name="M:Hazelcast.Config.ClientNetworkConfig.IsSmartRouting">
            <summary>Enabling ssl for client</summary>
        </member>
        <member name="T:Hazelcast.Config.ConfigurationException">
            <summary>
            A
            <see cref="T:Hazelcast.Core.HazelcastException"/>
            that is thrown when something is wrong with the server or client configuration.
            </summary>
        </member>
        <member name="T:Hazelcast.Config.IConfigPatternMatcher">
            <summary>The IConfigPatternMatcher provides a strategy to match an item name to a configuration pattern.</summary>
            <remarks>
            The IConfigPatternMatcher provides a strategy to match an item name to a configuration pattern.
            <p/>
            It is used on each Config.getXXXConfig() and ClientConfig.getXXXConfig() call for map, list, queue, set, executor, topic,
            semaphore etc., so for example <code>itemName</code> is the name of a map and <code>configPatterns</code> are all defined
            map configurations.
            <p/>
            If no configuration is found by the matcher it should return <tt>null</tt>. In this case the default config will be used
            for this item then. If multiple configurations are found by the matcher a
            <see cref="T:Hazelcast.Config.ConfigurationException"/>
            should be thrown.
            <p/>
            Since Hazelcast 3.5 the default matcher is
            <see cref="T:Hazelcast.Config.MatchingPointConfigPatternMatcher"/>
            .
            </remarks>
        </member>
        <member name="M:Hazelcast.Config.IConfigPatternMatcher.Matches(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>Returns the best match for an item name out of a list of configuration patterns.</summary>
            <param name="configPatterns">list of configuration patterns</param>
            <param name="itemName">item name to match</param>
            <returns>a key of configPatterns which matches the item name or <tt>null</tt> if nothing matches</returns>
            <exception cref="T:Hazelcast.Config.ConfigurationException">if ambiguous configurations are found</exception>
            <exception cref="T:Hazelcast.Config.ConfigurationException"/>
        </member>
        <member name="M:Hazelcast.Config.MatchingPointConfigPatternMatcher.Matches(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <exception cref="T:Hazelcast.Config.ConfigurationException" />
        </member>
        <member name="M:Hazelcast.Config.MatchingPointConfigPatternMatcher.GetMatchingPoint(System.String,System.String)">
            <summary>This method returns higher values the better the matching is.</summary>
            <param name="pattern">configuration pattern to match with</param>
            <param name="itemName">item name to match</param>
            <returns>-1 if name does not match at all, zero or positive otherwise</returns>
        </member>
        <member name="T:Hazelcast.Config.SSLConfig">
            <summary>
            COnfiguration for client to server secure communication via SSL
            </summary>
        </member>
        <member name="F:Hazelcast.Config.SSLConfig.CertificateName">
            <summary>
            Certifate Name; CN part of the Certificate Subject.
            </summary>
        </member>
        <member name="F:Hazelcast.Config.SSLConfig.ValidateCertificateChain">
            <summary>
            The property is used to configure ssl to enable certificate chain validation.
            </summary>
        </member>
        <member name="F:Hazelcast.Config.SSLConfig.ValidateCertificateName">
            <summary>
            The property is used to configure ssl to enable Certificate name validation
            </summary>
        </member>
        <member name="F:Hazelcast.Config.ClientConfig._credentials">
            <summary>
            The Security Configuration for custom Credentials:
            Name and Password that is used to connect to the cluster.
                Can be used instead of
                <see cref="T:Hazelcast.Config.GroupConfig">GroupConfig</see>
                in Hazelcast EE.
            </summary>
        </member>
        <member name="F:Hazelcast.Config.ClientConfig._executorPoolSize">
            <summary>pool-size for internal ExecutorService which handles responses etc.</summary>
        </member>
        <member name="F:Hazelcast.Config.ClientConfig._groupConfig">
            <summary>
            The Group Configuration properties like:
            Name and Password that is used to connect to the cluster.
            </summary>
            <remarks>
            The Group Configuration properties like:
            Name and Password that is used to connect to the cluster.
            </remarks>
        </member>
        <member name="F:Hazelcast.Config.ClientConfig._listenerConfigs">
            <summary>List of listeners that Hazelcast will automatically add as a part of initialization process.</summary>
            <remarks>
            List of listeners that Hazelcast will automatically add as a part of initialization process.
            Currently only supports
            <see cref="T:Hazelcast.Core.LifecycleListener">Hazelcast.Core.LifecycleListener</see>
            .
            </remarks>
        </member>
        <member name="F:Hazelcast.Config.ClientConfig._loadBalancer">
            <summary>Used to distribute the operations to multiple Endpoints.</summary>
        </member>
        <member name="F:Hazelcast.Config.ClientConfig._networkConfig">
            <summary>
            The Network Configuration properties like:
            addresses to connect, smart-routing, socket-options...
            </summary>
            <remarks>
            The Network Configuration properties like:
            addresses to connect, smart-routing, socket-options...
            </remarks>
        </member>
        <member name="T:Hazelcast.Config.GroupConfig">
            <summary>Contains the configuration for Hazelcast groups.</summary>
            <remarks>
                Contains the configuration for Hazelcast groups.
                With groups it is possible to create multiple clusters where each cluster has its own group and doesn't
                interfere with other clusters.
            </remarks>
        </member>
        <member name="M:Hazelcast.Config.GroupConfig.#ctor">
            <summary>Creates a GroupConfig with default group-name and group-password.</summary>
            <remarks>Creates a GroupConfig with default group-name and group-password.</remarks>
        </member>
        <member name="M:Hazelcast.Config.GroupConfig.#ctor(System.String)">
            <summary>Creates a GroupConfig with the given group-name and default group-password</summary>
            <param name="name">the name of the group</param>
            <exception cref="T:System.ArgumentException">if name is null.</exception>
        </member>
        <member name="M:Hazelcast.Config.GroupConfig.#ctor(System.String,System.String)">
            <summary>Creates a GroupConfig with the given group-name and group-password</summary>
            <param name="name">the name of the group</param>
            <param name="password">the password of the group</param>
            <exception cref="T:System.ArgumentException">if name or password is null.</exception>
        </member>
        <member name="M:Hazelcast.Config.GroupConfig.GetName">
            <summary>Gets the name of the group.</summary>
            <remarks>Gets the name of the group.</remarks>
            <returns>the name</returns>
        </member>
        <member name="M:Hazelcast.Config.GroupConfig.GetPassword">
            <summary>Gets the password to connec to to the group.</summary>
            <remarks>Gets the password to connec to to the group.</remarks>
            <returns>the password</returns>
        </member>
        <member name="M:Hazelcast.Config.GroupConfig.SetName(System.String)">
            <summary>Sets the group name.</summary>
            <remarks>Sets the group name.</remarks>
            <param name="name">the name to set</param>
            <returns>the updated GroupConfig.</returns>
            <exception cref="T:System.ArgumentException">if name is null.</exception>
        </member>
        <member name="M:Hazelcast.Config.GroupConfig.SetPassword(System.String)">
            <summary>Sets the password.</summary>
            <remarks>Sets the password.</remarks>
            <param name="password">the password to set</param>
            <returns>the updated GroupConfig.</returns>
            <exception cref="T:System.ArgumentException">if password is null.</exception>
        </member>
        <member name="T:Hazelcast.Config.InMemoryFormat">
            <summary>Storage format type of values stored in cluster</summary>
        </member>
        <member name="T:Hazelcast.Config.ListenerConfig">
            <summary>
                Contains the configuration for an
                <see cref="T:Hazelcast.Core.IEventListener">IEventListener</see>
                . The configuration contains either the classname
                of the IEventListener implementation, or the actual IEventListener instance.
            </summary>
        </member>
        <member name="M:Hazelcast.Config.ListenerConfig.#ctor">
            <summary>Creates a ListenerConfig without className/implementation.</summary>
            <remarks>Creates a ListenerConfig without className/implementation.</remarks>
        </member>
        <member name="M:Hazelcast.Config.ListenerConfig.#ctor(System.String)">
            <summary>Creates a ListenerConfig with the given className.</summary>
            <remarks>Creates a ListenerConfig with the given className.</remarks>
            <param name="className">the name of the IEventListener class.</param>
            <exception cref="T:System.ArgumentException">if className is null or an empty String.</exception>
        </member>
        <member name="M:Hazelcast.Config.ListenerConfig.#ctor(Hazelcast.Core.IEventListener)">
            <summary>Creates a ListenerConfig with the given implementation.</summary>
            <remarks>Creates a ListenerConfig with the given implementation.</remarks>
            <param name="implementation">the implementation to use as IEventListener.</param>
            <exception cref="T:System.ArgumentException">if the implementation is null.</exception>
        </member>
        <member name="M:Hazelcast.Config.ListenerConfig.GetClassName">
            <summary>Returns the name of the class of the IEventListener.</summary>
            <remarks>Returns the name of the class of the IEventListener. If no class is specified, null is returned.</remarks>
            <returns>the class name of the IEventListener.</returns>
            <seealso cref="M:Hazelcast.Config.ListenerConfig.SetClassName(System.String)">SetClassName(string)</seealso>
        </member>
        <member name="M:Hazelcast.Config.ListenerConfig.GetImplementation">
            <summary>Returns the IEventListener implementation.</summary>
            <remarks>Returns the IEventListener implementation. If none has been specified, null is returned.</remarks>
            <returns>the IEventListener implementation.</returns>
            <seealso cref="M:Hazelcast.Config.ListenerConfig.SetImplementation(Hazelcast.Core.IEventListener)" />
        </member>
        <member name="M:Hazelcast.Config.ListenerConfig.SetClassName(System.String)">
            <summary>Sets the class name of the IEventListener.</summary>
            <remarks>
                Sets the class name of the IEventListener.
                If a implementation was set, it will be removed.
            </remarks>
            <param name="className">the name of the class of the IEventListener.</param>
            <returns>the updated ListenerConfig.</returns>
            <exception cref="T:System.ArgumentException">if className is null or an empty String.</exception>
            <seealso cref="M:Hazelcast.Config.ListenerConfig.SetImplementation(Hazelcast.Core.IEventListener)" />
            <seealso cref="M:Hazelcast.Config.ListenerConfig.GetClassName">GetClassName()</seealso>
        </member>
        <member name="M:Hazelcast.Config.ListenerConfig.SetImplementation(Hazelcast.Core.IEventListener)">
            <summary>Sets the IEventListener implementation.</summary>
            <remarks>
                Sets the IEventListener implementation.
                If a className was set, it will be removed.
            </remarks>
            <param name="implementation">the IEventListener implementation.</param>
            <returns>the updated ListenerConfig.</returns>
            <exception cref="T:System.ArgumentException">the implementation is null.</exception>
            <seealso cref="M:Hazelcast.Config.ListenerConfig.SetClassName(System.String)">SetClassName(string)</seealso>
            <seealso cref="M:Hazelcast.Config.ListenerConfig.GetImplementation">GetImplementation()</seealso>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.GetClassName">
            <summary>
                Returns the name of the
                <see cref="T:Hazelcast.IO.ISocketInterceptor"/>
                implementation class
            </summary>
            <returns>name of the class</returns>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.GetImplementation">
            <summary>
                Returns the
                <see cref="T:Hazelcast.IO.ISocketInterceptor" />
                implementation object
            </summary>
            <returns>SocketInterceptor implementation object</returns>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.GetProperties">
            <summary>Gets all properties.</summary>
            <remarks>Gets all properties.</remarks>
            <returns>the properties.</returns>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.GetProperty(System.String)">
            <summary>Gets a property.</summary>
            <remarks>Gets a property.</remarks>
            <param name="name">the name of the property to get.</param>
            <returns>the value of the property, null if not found</returns>
            <exception cref="T:System.ArgumentNullException">if name is null.</exception>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.IsEnabled">
            <summary>Returns if this configuration is enabled</summary>
            <returns>true if enabled, false otherwise</returns>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.SetClassName(System.String)">
            <summary>
                Sets the name for the
                <see cref="T:Hazelcast.IO.ISocketInterceptor" />
                implementation class
            </summary>
            <param name="className">
                the name of the
                <see cref="T:Hazelcast.IO.ISocketInterceptor" />
                implementation class to set
            </param>
            <returns>this SocketInterceptorConfig instance</returns>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.SetEnabled(System.Boolean)">
            <summary>Enables and disables this configuration</summary>
            <param name="enabled"></param>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.SetImplementation(System.Object)">
            <summary>
                Sets the
                <see cref="T:Hazelcast.IO.ISocketInterceptor" />
                implementation object
            </summary>
            <param name="implementation">implementation object</param>
            <returns>this SocketInterceptorConfig instance</returns>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.SetProperties(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Sets the properties.</summary>
            <remarks>Sets the properties.</remarks>
            <param name="properties">the properties to set.</param>
            <returns>the updated SSLConfig.</returns>
            <exception cref="T:System.ArgumentException">if properties is null.</exception>
        </member>
        <member name="M:Hazelcast.Config.SocketInterceptorConfig.SetProperty(System.String,System.String)">
            <summary>Sets a property.</summary>
            <remarks>Sets a property.</remarks>
            <param name="name">the name of the property to set.</param>
            <param name="value">the value of the property to set</param>
            <returns>the updated SocketInterceptorConfig</returns>
            <exception cref="T:System.ArgumentNullException">if name or value is null.</exception>
        </member>
        <member name="M:Hazelcast.Config.XmlClientConfigBuilder.HandleConfig(System.Xml.XmlElement)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Config.XmlClientConfigBuilder.HandleListeners(System.Xml.XmlNode)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Config.XmlClientConfigBuilder.HandleProxyFactories(System.Xml.XmlNode)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Config.XmlClientConfigBuilder.HandleProxyFactory(System.Xml.XmlNode)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Config.XmlClientConfigBuilder.HandleSecurity(System.Xml.XmlNode)">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:Hazelcast.Core.IAggregator`1">
            <summary>
            Simple interface for marking aggregators. An aggregator implementain must support hazelcast serialization and
            have a counterpart on server side.
            </summary>
            <typeparam name="TResult">aggregated result type</typeparam>
        </member>
        <member name="T:Hazelcast.Core.AbstractAggregator`1">
            <summary>
            Base builtin aggregator
            </summary>
        </member>
        <member name="T:Hazelcast.Core.BigIntegerSumAggregator">
            <summary>
            An aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts only BigInteger input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.CountAggregator">
            <summary>
            an aggregator that counts the input values. Accepts nulls as input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.DoubleAverageAggregator">
            <summary>
            an aggregator that calculates the average of the input values.
            Does NOT accept null input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.DoubleSumAggregator">
            <summary>
            An aggregator that calculates the sum of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only double input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.FixedSumAggregator">
            <summary>
            An aggregator that calculates the sum of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts float or double input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.FloatingPointSumAggregator">
            <summary>
            an aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts float or double input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.IntegerAverageAggregator">
            <summary>
            an aggregator that calculates the average of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only int input values
            </summary>
        </member>
        <member name="T:Hazelcast.Core.IntegerSumAggregator">
            <summary>
            an aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts only int input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.LongAverageAggregator">
            <summary>
            an aggregator that calculates the average of the input values.
            Does NOT accept null input values.
            Accepts only long input values
            </summary>
        </member>
        <member name="T:Hazelcast.Core.LongSumAggregator">
            <summary>
            an aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts only long input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.MaxAggregator`1">
            <summary>
            an aggregator that calculates the max of the input values.
            Accepts null input values
            </summary>
        </member>
        <member name="T:Hazelcast.Core.MinAggregator`1">
            <summary>
            an aggregator that calculates the min of the input values.
            Accepts null input values
            </summary>
        </member>
        <member name="T:Hazelcast.Core.NumberAverageAggregator">
            <summary>
            an aggregator that calculates the average of the input values.
            Does NOT accept null input values nor null extracted values.
            Accepts float or double input values.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.Aggregators">
            <summary>
            A utility class to create basic <see cref="T:Hazelcast.Core.IAggregator`1"/> instances.
            </summary>
            <remarks>
            Min/Max/Average aggregators are type specific, so an IntegerAvg() aggregator expects all elements to be integers.
            There is no conversion executed while accumulating, so if there is any other type met an exception will be thrown.
            <br/>
            In order to operate on a generic Number type use the <see cref="M:Hazelcast.Core.Aggregators.FixedPointSum(System.String)"/>,
            <see cref="M:Hazelcast.Core.Aggregators.FloatingPointSum(System.String)"/> and <see cref="M:Hazelcast.Core.Aggregators.NumberAvg(System.String)"/> aggregators.
            All of them will convert the given number to either Long or Double during the accumulation phase.
            It will result in a lot of allocations since each number has to be converted, but it enables the user
            to operate on the whole family of numbers. It is especially useful if the numbers given to the aggregators
            may not be of one type only.
            <br/>
            The attributePath given in the factory method allows the aggregator to operate on the value extracted by navigating
            to the given attributePath on each object that has been returned from a query.
            The attribute path may be simple, e.g. "name", or nested "address.city".
            <br/>
            If an aggregator does not accept null values pass a predicate to the aggregate call that will filter them out.
            <br/>
            If the input value or the extracted value is a collection it won't be "unfolded" - so for example
            count aggregation on "person.postalCodes" will return 1 for each input object and not the size of the collection.
            In order to calculate the size of the collection use the [any] operator, e.g. "person.postalCodes[any]".
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.Count">
            <summary>
            an aggregator that counts the input values. Accepts nulls as input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.CountAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.Count(System.String)">
            <summary>
            an aggregator that counts the input values extracted from the given attributePath.
            Accepts null input values and null extracted values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.CountAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.DoubleAvg">
            <summary>
            an aggregator that calculates the average of the input values.
            Does NOT accept null input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.DoubleAverageAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.DoubleAvg(System.String)">
            <summary>
            an aggregator that calculates the average of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only double input values
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.DoubleAverageAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.IntegerAvg">
            <summary>
             an aggregator that calculates the average of the input values.
            Does NOT accept null input values.
            Accepts only int input values
            </summary>
            <returns></returns>
            <returns><see cref="T:Hazelcast.Core.IntegerAverageAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.IntegerAvg(System.String)">
            <summary>
            an aggregator that calculates the average of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only int input values
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.IntegerAverageAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.LongAvg">
            <summary>
            an aggregator that calculates the average of the input values.
            Does NOT accept null input values.
            Accepts only long input values
            </summary>
            <returns><see cref="T:Hazelcast.Core.LongAverageAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.LongAvg(System.String)">
            <summary>
            an aggregator that calculates the average of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only long input values
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.LongAverageAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.NumberAvg">
            <summary>
            an aggregator that calculates the average of the input values.
            Does NOT accept null input values.
            Accepts float or double input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.NumberAverageAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.NumberAvg(System.String)">
            <summary>
            an aggregator that calculates the average of the input values.
            Does NOT accept null input values nor null extracted values.
            Accepts float or double input values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.NumberAverageAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.Max``1">
            <summary>
            an aggregator that calculates the max of the input values.
            Accepts null input values
            </summary>
            <returns><see cref="T:Hazelcast.Core.MaxAggregator`1"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.Max``1(System.String)">
            <summary>
            an aggregator that calculates the max of the input values extracted from the given attributePath.
            Accepts null input values and null extracted values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.MaxAggregator`1"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.Min``1">
            <summary>
            an aggregator that calculates the min of the input values.
            Accepts null input values
            </summary>
            <returns><see cref="T:Hazelcast.Core.MinAggregator`1"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.Min``1(System.String)">
            <summary>
            an aggregator that calculates the min of the input values extracted from the given attributePath.
            Accepts null input values and null extracted values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.MinAggregator`1"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.BigIntegerSum">
            <summary>
            An aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts only BigInteger input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.BigIntegerSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.BigIntegerSum(System.String)">
            <summary>
            an aggregator that calculates the sum of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only BigInteger input values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.BigIntegerSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.DoubleSum">
            <summary>
            an aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts only double input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.DoubleSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.DoubleSum(System.String)">
            <summary>
            An aggregator that calculates the sum of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only double input values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.DoubleSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.IntegerSum">
            <summary>
            an aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts only int input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.IntegerSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.IntegerSum(System.String)">
            <summary>
            An aggregator that calculates the sum of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only int input values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.IntegerSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.LongSum">
            <summary>
            an aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts only long input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.LongSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.LongSum(System.String)">
            <summary>
            An aggregator that calculates the sum of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts only long input values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.LongSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.FixedPointSum">
            <summary>
            an aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts float or double input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.FixedSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.FixedPointSum(System.String)">
            <summary>
            An aggregator that calculates the sum of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts float or double input values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.FixedSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.FloatingPointSum">
            <summary>
            an aggregator that calculates the sum of the input values.
            Does NOT accept null input values.
            Accepts float or double input values.
            </summary>
            <returns><see cref="T:Hazelcast.Core.FloatingPointSumAggregator"/></returns>
        </member>
        <member name="M:Hazelcast.Core.Aggregators.FloatingPointSum(System.String)">
            <summary>
            An aggregator that calculates the sum of the input values extracted from the given attributePath.
            Does NOT accept null input values nor null extracted values.
            Accepts float or double input values.
            </summary>
            <param name="attributePath">attribute Path</param>
            <returns><see cref="T:Hazelcast.Core.FloatingPointSumAggregator"/></returns>
        </member>
        <member name="T:Hazelcast.Core.IAtomicLong">
            <summary>
                IAtomicLong is a redundant and highly available distributed Atomic Long
            </summary>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.AddAndGet(System.Int64)">
            <summary>Returns the name of this IAtomicLong instance.</summary>
            <remarks>Returns the name of this IAtomicLong instance.</remarks>
            <returns>name of this instance</returns>
            <summary>Atomically adds the given value to the current value.</summary>
            <remarks>Atomically adds the given value to the current value.</remarks>
            <param name="delta">the value to add</param>
            <returns>the updated value</returns>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.CompareAndSet(System.Int64,System.Int64)">
            <summary>
                Atomically sets the value to the given updated value
                only if the current value
                <code>==</code>
                the expected value.
            </summary>
            <param name="expect">the expected value</param>
            <param name="update">the new value</param>
            <returns>
                true if successful; or false if the actual value
                was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.DecrementAndGet">
            <summary>Atomically decrements the current value by one.</summary>
            <remarks>Atomically decrements the current value by one.</remarks>
            <returns>the updated value</returns>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.Get">
            <summary>Gets the current value.</summary>
            <remarks>Gets the current value.</remarks>
            <returns>the current value</returns>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.GetAndAdd(System.Int64)">
            <summary>Atomically adds the given value to the current value.</summary>
            <remarks>Atomically adds the given value to the current value.</remarks>
            <param name="delta">the value to add</param>
            <returns>the old value before the add</returns>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.GetAndIncrement">
            <summary>Atomically increments the current value by one.</summary>
            <remarks>Atomically increments the current value by one.</remarks>
            <returns>the old value</returns>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.GetAndSet(System.Int64)">
            <summary>Atomically sets the given value and returns the old value.</summary>
            <remarks>Atomically sets the given value and returns the old value.</remarks>
            <param name="newValue">the new value</param>
            <returns>the old value</returns>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.IncrementAndGet">
            <summary>Atomically increments the current value by one.</summary>
            <remarks>Atomically increments the current value by one.</remarks>
            <returns>the updated value</returns>
        </member>
        <member name="M:Hazelcast.Core.IAtomicLong.Set(System.Int64)">
            <summary>Atomically sets the given value.</summary>
            <remarks>Atomically sets the given value.</remarks>
            <param name="newValue">the new value</param>
        </member>
        <member name="T:Hazelcast.Core.IIdGenerator">
            <summary>Cluster-wide unique id generator.</summary>
            <remarks>Cluster-wide unique id generator.</remarks>
        </member>
        <member name="M:Hazelcast.Core.IIdGenerator.Init(System.Int64)">
            <summary>Try to initialize this <c>IIdGenerator</c> instance with given id</summary>
            <returns>true if initialization success</returns>
        </member>
        <member name="M:Hazelcast.Core.IIdGenerator.NewId">
            <summary>Generates and returns cluster-wide unique id.</summary>
            <remarks>
                Generates and returns cluster-wide unique id.
                Generated ids are guaranteed to be unique for the entire cluster
                as long as the cluster is live. If the cluster restarts then
                id generation will start from 0.
            </remarks>
            <returns>cluster-wide new unique id</returns>
        </member>
        <member name="T:Hazelcast.Core.IHList`1">
            <summary>
                Concurrent, distributed implementation of <see cref="T:System.Collections.Generic.IList`1"/>IList 
            </summary>
        </member>
        <member name="M:Hazelcast.Core.IHList`1.Add(System.Int32,`0)">
            <summary>
            Inserts the specified element at the specified position in this list.
            Shifts the element currently at that position
            (if any) and any subsequent elements to the right (adds one to their
            indices).
            </summary>
            <param name="index">index at which the specified element is to be inserted</param>
            <param name="element">element to be inserted</param>
        </member>
        <member name="M:Hazelcast.Core.IHList`1.AddAll``1(System.Int32,System.Collections.Generic.ICollection{``0})">
            <summary>
            Inserts all of the elements in the specified collection into this
            list at the specified position (optional operation).  Shifts the
            element currently at that position (if any) and any subsequent
            elements to the right (increases their indices).  The new elements
            will appear in this list in the order that they are returned by the
            specified collection's iterator.  The behavior of this operation is
            undefined if the specified collection is modified while the
            operation is in progress.  (Note that this will occur if the specified
            collection is this list, and it's nonempty.)
            </summary>
            <param name="index">index at which to insert the first element from the specified collection</param>
            <param name="c">collection containing elements to be added to this list</param>
            <typeparam name="TE"></typeparam>
            <returns><tt>true</tt> if this list changed as a result of the call</returns>
        </member>
        <member name="M:Hazelcast.Core.IHList`1.Get(System.Int32)">
            <summary>
            Returns the element in the specified position in this list
            </summary>
            <param name="index">index of the element to return</param>
            <returns>the element at the specified position in the list</returns>
        </member>
        <member name="M:Hazelcast.Core.IHList`1.LastIndexOf(`0)">
            <summary>
            Returns the index of the last occurrence of the specified element
            in this list, or -1 if this list does not contain the element.
            More formally, returns the highest index <tt>i</tt> such that
            <tt>(o == null ? get(i) == null : o.equals(get(i)))</tt>
            or -1 if there is no such index.
            </summary>
            <param name="o">element to search for</param>
            <returns>the index of the last occurrence of the specified element in
             this list, or -1 if this list does not contain the element</returns>
        </member>
        <member name="M:Hazelcast.Core.IHList`1.Remove(System.Int32)">
            <summary>
            Removes the first occurrence of the specified element from this list,
            if it is present (optional operation).  If this list does not contain
            the element, it is unchanged.  More formally, removes the element with
            the lowest index <tt>i</tt> such that
            <tt>(o==null ? get(i)==null : o.equals(get(i)))</tt>
            (if such an element exists).  Returns <tt>true</tt> if this list
            contained the specified element (or equivalently, if this list changed
            as a result of the call).
            </summary>
            <param name="index">element to be removed from this list, if present</param>
            <returns><tt>true</tt> if this list contained the specified element</returns>
        </member>
        <member name="M:Hazelcast.Core.IHList`1.Set(System.Int32,`0)">
            <summary>
            Replaces the element at the specified position in this list with the
            specified element.
            </summary>
            <param name="index">index index of the element to replace</param>
            <param name="element">element to be stored at the specified position</param>
            <returns></returns>
        </member>
        <member name="M:Hazelcast.Core.IHList`1.SubList(System.Int32,System.Int32)">
            <summary>
            Returns a view of the portion of this list between the specified
            <tt>fromIndex</tt>, inclusive, and <tt>toIndex</tt>, exclusive.  (If
            <tt>fromIndex</tt> and <tt>toIndex</tt> are equal, the returned list is
            empty.) 
            </summary>
            <param name="fromIndex">low endpoint (inclusive) of the subList</param>
            <param name="toIndex">high endpoint (exclusive) of the subList</param>
            <returns>a view of the specified range within this list</returns>
        </member>
        <member name="T:Hazelcast.Core.IMap`2">
            <summary>
                Concurrent, distributed, observable and queryable map.
            </summary>
            <remarks>
                Concurrent, distributed, observable and queryable map.
                <p />
                <p>
                    <b>
                        This class is <i>not</i> a general-purpose <c>ConcurrentMap</c> implementation! While this class
                        implements
                        the <c>Map</c> interface, it intentionally violates <c>Map's</c> general contract, which mandates the
                        use of the <c>Equals</c> method when comparing objects. Instead of the <c>Equals</c> method this
                        implementation compares the serialized byte version of the objects.
                    </b>
                </p>
                <p />
                <p>
                    <b>Gotchas:</b>
                    <ul>
                        <li>
                            Methods, including but not limited to <c>Get</c>, <c>ContainsKey</c>,
                            <c>ContainsValue</c>, <c>Evict</c>, <c>Remove</c>, <c>Put</c>,
                            <c>PutIfAbsent</c>, <c>Replace</c>, <c>Lock</c>,
                            <c>Unlock</c>, do not use <c>GetHashCode</c> and <c>Equals</c> implementations of keys,
                            instead they use <c>GetHashCode</c> and <c>Equals</c> of binary (serialized) forms of the objects.
                        </li>
                        <li>
                            <c>Get</c> method returns a clone of original values, modifying the returned value does not
                            change the actual value in the map. One should put modified value back to make changes visible to all
                            nodes.
                            For additional info see
                            <see cref="M:Hazelcast.Core.IMap`2.Get(System.Object)">IMap&lt;K, V&gt;.Get(object)</see>
                        </li>
                        <li>
                            Methods, including but not limited to <c>keySet</c>, <c>values</c>, <c>entrySet</c>,
                            return a collection clone of the values. The collection is <b>NOT</b> backed by the map,
                            so changes to the map are <b>NOT</b> reflected in the collection, and vice-versa.
                        </li>
                    </ul>
                </p>
            </remarks>
            <typeparam name="TKey">type of the Key</typeparam>
            <typeparam name="TValue">type of the Value</typeparam>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.AddEntryListener(Hazelcast.Core.IEntryListener{`0,`1},System.Boolean)">
            <summary>
                Adds an entry listener for this map.
            </summary>
            <remarks>
                Adds an entry listener for this map. Listener will get notified for all map add/remove/update/evict events.
            </remarks>
            <param name="listener">entry listener</param>
            <param name="includeValue"><c>true</c> if <c>EntryEvent</c> should contain the value.</param>
            <returns>returns registration id</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.AddEntryListener(Hazelcast.Core.IEntryListener{`0,`1},`0,System.Boolean)">
            <summary>Adds the specified entry listener for the specified key.</summary>
            <remarks>
                Adds the specified entry listener for the specified key.
                The listener will get notified for all
                add/remove/update/evict events of the specified key only.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>hashCode</c> and <c>equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>hashCode</c> and <c>equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="listener">entry listener</param>
            <param name="key">key to listen</param>
            <param name="includeValue">
                <c>true</c> if <c>EntryEvent</c> should
                contain the value.
            </param>
            <returns>returns registration id</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.AddEntryListener(Hazelcast.Core.IEntryListener{`0,`1},Hazelcast.Core.IPredicate,`0,System.Boolean)">
            <summary>Adds an continuous entry listener for this map.</summary>
            <remarks>
                Adds an continuous entry listener for this map. Listener will get notified
                for map add/remove/update/evict events filtered by given predicate.
            </remarks>
            <param name="listener">entry listener</param>
            <param name="predicate">predicate for filtering entries</param>
            <param name="key">key to listen</param>
            <param name="includeValue">
                <c>true</c> if <c>EntryEvent</c> should
                contain the value.
            </param>
            <returns>returns registration id</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.AddEntryListener(Hazelcast.Core.IEntryListener{`0,`1},Hazelcast.Core.IPredicate,System.Boolean)">
            <summary>Adds an continuous entry listener for this map.</summary>
            <remarks>
                Adds an continuous entry listener for this map. Listener will get notified
                for map add/remove/update/evict events filtered by given predicate.
            </remarks>
            <param name="listener">entry listener</param>
            <param name="predicate">predicate for filtering entries</param>
            <param name="includeValue">
                <c>true</c> if <c>EntryEvent</c> should
                contain the value.
            </param>
            <returns>returns registration id</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.AddIndex(System.String,System.Boolean)">
            <summary>
                Adds an index to this map for the specified entries so
                that queries can run faster.
            </summary>
            <remarks>
                Adds an index to this map for the specified entries so
                that queries can run faster.
                <p />
                Let's say your map values are Employee objects.
                <code>
            public class Employee :IPortable
            {
                private bool active = false;
                private int age;
                private string name = null;
                // other fields.
                
            }
            </code>
                <p />
                If you are querying your values mostly based on age and active then
                you should consider indexing these fields.
                <code>
            var imap = Hazelcast.GetMap("employees");
            imap.AddIndex("age", true);        // ordered, since we have ranged queries for this field
            imap.AddIndex("active", false);    // not ordered, because boolean field cannot have range
            </code>
                <p />
                Index attribute should either have a getter method or be public.
                You should also make sure to add the indexes before adding
                entries to this map.
            </remarks>
            <param name="attribute">attribute of value</param>
            <param name="ordered">
                <c>true</c> if index should be ordered,
                <c>false</c> otherwise.
            </param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.AddInterceptor(Hazelcast.Map.IMapInterceptor)">
            <summary>Adds an interceptor for this map.</summary>
            <remarks>
                Adds an interceptor for this map. Added interceptor will intercept operations
                and execute user defined methods and will cancel operations if user defined method throw exception.
            </remarks>
            <param name="interceptor">map interceptor</param>
            <returns>id of registered interceptor</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Aggregate``1(Hazelcast.Core.IAggregator{``0})">
            <summary>
            Applies the aggregation logic on all map entries and returns the result
            </summary>
            <remarks>
            Fast-Aggregations are the successor of the Map-Reduce Aggregators.
            They are equivalent to the Map-Reduce Aggregators in most of the use-cases, but instead of running on the
            Map-Reduce engine they run on the Query infrastructure. Their performance is tens to hundreds times better
            due to the fact that they run in parallel for each partition and are highly optimized for speed and low
            memory consumption
            </remarks>
            <param name="aggregator">
            Aggregator to aggregate the entries with.
            This must be serializable via hazelcast serialization and have a counterpart on server side.
            One of the builtin <see cref="T:Hazelcast.Core.Aggregators"/> or a custom <see cref="T:Hazelcast.Core.IAggregator`1"/> implementation can be used.
            </param>
            <typeparam name="TResult">type of the result</typeparam>
            <returns>the result of the given type</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Aggregate``1(Hazelcast.Core.IAggregator{``0},Hazelcast.Core.IPredicate)">
            <summary>
            Applies the aggregation logic on all map entries and returns the result
            </summary>
            <remarks>
            Fast-Aggregations are the successor of the Map-Reduce Aggregators.
            They are equivalent to the Map-Reduce Aggregators in most of the use-cases, but instead of running on the
            Map-Reduce engine they run on the Query infrastructure. Their performance is tens to hundreds times better
            due to the fact that they run in parallel for each partition and are highly optimized for speed and low
            memory consumption
            </remarks>
            <param name="aggregator">
            Aggregator to aggregate the entries with.
            This must be serializable via hazelcast serialization and have a counterpart on server side.
            One of the builtin <see cref="T:Hazelcast.Core.Aggregators"/> or a custom <see cref="T:Hazelcast.Core.IAggregator`1"/> implementation can be used.
            </param>
            <param name="predicate">
            predicate to filter the entries with.
            This must be serializable via hazelcast serialization and have a counterpart on server side.
            </param>
            <typeparam name="TResult">type of the result</typeparam>
            <returns>the result of the given type</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Project``1(Hazelcast.Core.IProjection)">
            <summary>
            Applies the projection logic on all map entries and returns the result
            </summary>
            <param name="projection">
            Projection to transform the entries with. May return null.
            This must be serializable via hazelcast serialization and have a counterpart on server side.
            </param>
            <typeparam name="TResult">type of the result</typeparam>
            <returns>the result of the given type</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Project``1(Hazelcast.Core.IProjection,Hazelcast.Core.IPredicate)">
            <summary>
            Applies the projection logic on all map entries and returns the result
            </summary>
            <param name="projection">
            Projection to transform the entries with. May return null.
            This must be serializable via hazelcast serialization and have a counterpart on server side.
            </param>
            <param name="predicate">
            predicate to filter the entries with.
            This must be serializable via hazelcast serialization and have a counterpart on server side.
            </param>
            <typeparam name="TResult">type of the result</typeparam>
            <returns>the result of the given type</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Clear">
            <summary>
                Removes all of the mappings from this map (optional operation).
            </summary>
            <remarks>
                The map will be empty after this call returns.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.ContainsKey(System.Object)">
            <summary>
                Determines whether this map contains an entry for the specified key.
            </summary>
            <remarks>
                Determines whether this map contains an entry for the specified key.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    
                    This method uses <c>hashCode</c> and <c>equals</c> of binary form of
                    the <c>key</c>, not the actual implementations of <c>hashCode</c> and <c>equals</c>
                    defined in <c>key</c>'s class.
                </p>
            </remarks>
            <param name="key">The key.</param>
            <returns><c>true</c> if the specified key contains key; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.ContainsValue(System.Object)">
            <summary>
                Determines whether this map contains one or more keys to the specified value
            </summary>
            <param name="value">The value.</param>
            <returns>Returns <c>true</c> if this map contains one or more keys to the specified value</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Delete(System.Object)">
            <summary>
                Removes the mapping for a key from this map if it is present
                (optional operation).
            </summary>
            <remarks>
                Removes the mapping for a key from this map if it is present
                (optional operation).
                <p>
                    this operation does not return removed value to avoid serialization cost of returned value.
                    If the removed value will not be used, delete operation
                    should be preferred over remove operation for a better performance.
                </p>
                <p>
                    The map will not contain a mapping for the specified key once the call returns.
                </p>
            </remarks>
            <param name="key">key whose mapping is to be removed from the map</param>
            <exception cref="T:System.InvalidCastException">
                if the key is of an inappropriate type for
                this map (optional)
            </exception>
            <exception cref="T:System.ArgumentNullException">if the specified key is null.</exception>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.EntrySet">
            <summary>
                Returns a
                <see cref="T:System.Collections.Generic.ICollection`1" />
                clone of the mappings contained in this map.
                The set is <b>NOT</b> backed by the map,
                so changes to the map are <b>NOT</b> reflected in the set, and vice-versa.
            </summary>
            <returns>a <see cref="T:System.Collections.Generic.ISet`1" /> clone of the keys mappings in this map</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.EntrySet(Hazelcast.Core.IPredicate)">
            <summary>
                Queries the map based on the specified predicate and
                returns the matching entries.
            </summary>
            <remarks>
                Queries the map based on the specified predicate and
                returns the matching entries.
                <p />
                Specified predicate runs on all members in parallel.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                The set is <b>NOT</b> backed by the map,
                so changes to the map are <b>NOT</b> reflected in the set, and vice-versa.
            </remarks>
            <param name="predicate">query criteria</param>
            <returns>result entry <see cref="T:System.Collections.Generic.ISet`1" /> of the query</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Evict(`0)">
            <summary>Evicts the specified key from this map.</summary>
            <remarks>
                Evicts the specified key from this map. If
                a <c>MapStore</c> defined for this map, then the entry is not
                deleted from the underlying <c>MapStore</c>, evict only removes
                the entry from the memory.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key to evict</param>
            <returns><c>true</c> if the key is evicted, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.EvictAll">
            <summary>Evicts all keys from this map except the locked ones.</summary>
            <remarks>
            Evicts all keys from this map except the locked ones.
            <p/>
            <see cref="M:Hazelcast.Core.IMap`2.Clear"/>
            method.
            <p/>
            The EVICT_ALL event is fired for any registered listeners.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.ExecuteOnKey(`0,Hazelcast.Map.IEntryProcessor)">
            <summary>Applies the user defined EntryProcessor to the entry mapped by the key.</summary>
            <param name="key">key</param>
            <param name="entryProcessor">
                The user defined <see cref="T:Hazelcast.Map.IEntryProcessor"/>. This object must have a hazelcast serializable
                EntryProcessor counterpart registered on server side with the actual
                <c>org.hazelcast.map.EntryProcessor</c> implementation.
            </param>
            <returns>result of entry process</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.ExecuteOnKeys(System.Collections.Generic.ISet{`0},Hazelcast.Map.IEntryProcessor)">
            <summary>Applies the user defined EntryProcessor to the entries mapped by the collection of keys.</summary>
            <param name="keys">keys to process</param>
            <param name="entryProcessor">
                The user defined <see cref="T:Hazelcast.Map.IEntryProcessor"/>. This object must have a hazelcast serializable
                EntryProcessor counterpart registered on server side with the actual
                <c>org.hazelcast.map.EntryProcessor</c> implementation.
            </param>
            <returns>the results mapped by each key in the collection.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.ExecuteOnEntries(Hazelcast.Map.IEntryProcessor)">
            <summary>Applies the user defined EntryProcessor to the all entries in the map.</summary>
            <param name="entryProcessor">
                The user defined <see cref="T:Hazelcast.Map.IEntryProcessor"/>. This object must have a hazelcast serializable
                EntryProcessor counterpart registered on server side with the actual
                <c>org.hazelcast.map.EntryProcessor</c> implementation.
            </param>
            <returns></returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.ExecuteOnEntries(Hazelcast.Map.IEntryProcessor,Hazelcast.Core.IPredicate)">
            <summary>
                Applies the user defined EntryProcessor to the entries in the map which satisfies provided predicate.
            </summary>
            <param name="entryProcessor">
                The user defined <see cref="T:Hazelcast.Map.IEntryProcessor"/>. This object must have a hazelcast serializable
                EntryProcessor counterpart registered on server side with the actual
                <c>org.hazelcast.map.EntryProcessor</c> implementation.
            </param>
            <param name="predicate">predicate for filtering the entries on server side</param>
            <returns>the results mapped by each key in the map</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Flush">
            <summary>
                If this map has a MapStore this method flushes
                all the local dirty entries by calling <c>MapStore.storeAll()</c> and/or <c>MapStore.deleteAll()</c>
            </summary>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.ForceUnlock(`0)">
            <summary>Releases the lock for the specified key regardless of the lock owner.</summary>
            <remarks>
                Releases the lock for the specified key regardless of the lock owner.
                It always successfully unlocks the key, never blocks
                and returns immediately.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key to lock.</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Get(System.Object)">
            <summary>
                Returns the value for the specified key, or <c>null</c> if this map does not contain this key.
            </summary>
            <remarks>
                Returns the value for the specified key, or <c>null</c> if this map does not contain this key.
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns a clone of original value, modifying the returned value does not change
                    the actual value in the map. One should put modified value back to make changes visible to all nodes.
                    <code>
            var value = map.Get(key);
            value.UpdateSomeProperty();
            map.put(key, value);
            </code>
                </p>
                <p />
                <p>
                    <b>Warning-2:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
                <p />
            </remarks>
            <param name="key">key</param>
            <returns>value</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.GetAll(System.Collections.Generic.ICollection{`0})">
            <summary>Returns the entries for the given keys.</summary>
            <remarks>
                Returns the entries for the given keys.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                The returned map is <b>NOT</b> backed by the original map,
                so changes to the original map are <b>NOT</b> reflected in the returned map, and vice-versa.
                <p />
                <p>
                    <b>Warning-2:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="keys">keys to get</param>
            <returns>map of entries</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.GetAsync(`0)">
            <summary>Asynchronously gets the given key.</summary>
            <remarks>
                Asynchronously gets the given key.
                <code>
            Task&lt;V&gt; task = map.GetAsync(key);
            // do some other stuff, when ready get the result
            V value = task.Result;
            </code>
                Task.Result will block until the actual map.Get() completes.
                If the application requires timely response,
                then task.Wait(timeout) can be used.
                <code>
            try
            {
                Task&lt;V&gt; task = map.GetAsync(key);
                if(task.Wait(TimeSpan.FromMilliseconds(40)))
                {
                   V value = task.Result; 
                }
                else
                {
                 //Result not ready
                }
            </code>
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">the key of the map entry</param>
            <returns>Task&lt;V&gt; from which the value of the key can be retrieved.</returns>
            <seealso cref="T:System.Threading.Tasks.Task`1" />
        </member>
        <member name="M:Hazelcast.Core.IMap`2.GetEntryView(`0)">
            <summary>Returns the <c>EntryView</c> for the specified key.</summary>
            <remarks>
                Returns the <c>EntryView</c> for the specified key.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns a clone of original mapping, modifying the returned value does not change
                    the actual value in the map. One should put modified value back to make changes visible to all nodes.
                </p>
                <p />
                <p>
                    <b>Warning-2:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key of the entry</param>
            <returns><c>EntryView</c> of the specified key</returns>
            <seealso cref="T:Hazelcast.Core.IEntryView`2" />
        </member>
        <member name="M:Hazelcast.Core.IMap`2.IsEmpty">
            <summary>Returns <c>true</c> if this map contains no entries.</summary>
            <remarks>Returns <c>true</c> if this map contains no entries.</remarks>
            <returns><c>true</c> if this map contains no entries</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.IsLocked(`0)">
            <summary>Checks the lock for the specified key.</summary>
            <remarks>
                Checks the lock for the specified key.
                <p />
                If the lock is acquired then returns true, else false.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key to lock to be checked.</param>
            <returns><c>true</c> if lock is acquired, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.KeySet">
            <summary>Returns a set clone of the keys contained in this map.</summary>
            <remarks>
                Returns a set clone of the keys contained in this map.
                The set is <b>NOT</b> backed by the map,
                so changes to the map are <b>NOT</b> reflected in the set, and vice-versa.
            </remarks>
            <returns>a <see cref="T:System.Collections.Generic.ISet`1" /> clone of the keys contained in this map</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.KeySet(Hazelcast.Core.IPredicate)">
            <summary>
                Queries the map based on the specified predicate and
                returns the keys of matching entries.
            </summary>
            <remarks>
                Queries the map based on the specified predicate and
                returns the keys of matching entries.
                <p />
                Specified predicate runs on all members in parallel.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                The set is <b>NOT</b> backed by the map,
                so changes to the map are <b>NOT</b> reflected in the set, and vice-versa.
            </remarks>
            <param name="predicate">query criteria</param>
            <returns>result key <see cref="T:System.Collections.Generic.ISet`1" /> of the query</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Lock(`0)">
            <summary>Acquires the lock for the specified key.</summary>
            <remarks>
                Acquires the lock for the specified key.
                <p />
                If the lock is not available then
                the current thread becomes disabled for thread scheduling
                purposes and lies dormant until the lock has been acquired.
                <p />
                Scope of the lock is this map only.
                Acquired lock is only for the key in this map.
                <p />
                Locks are re-entrant so if the key is locked N times then
                it should be unlocked N times before another thread can acquire it.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key to lock.</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Lock(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Acquires the lock for the specified key for the specified lease time.</summary>
            <remarks>
                Acquires the lock for the specified key for the specified lease time.
                <p />
                After lease time, lock will be released..
                <p />
                If the lock is not available then
                the current thread becomes disabled for thread scheduling
                purposes and lies dormant until the lock has been acquired.
                <p />
                Scope of the lock is this map only.
                Acquired lock is only for the key in this map.
                <p />
                Locks are re-entrant so if the key is locked N times then
                it should be unlocked N times before another thread can acquire it.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key to lock.</param>
            <param name="leaseTime">time to wait before releasing the lock.</param>
            <param name="timeUnit"><see cref="T:Hazelcast.Core.TimeUnit" /> for the ttl</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Put(`0,`1)">
            <summary>
                Associates the specified value with the specified key in this map
                If the map previously contained a mapping for
                the key, the old value is replaced by the specified value.
            </summary>
            <remarks>
                Associates the specified value with the specified key in this map
                If the map previously contained a mapping for
                the key, the old value is replaced by the specified value.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns a clone of previous value, not the original (identically equal) value
                    previously put into map.
                </p>
                <p>
                    <b>Warning-2:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key</param>
            <param name="value">value</param>
            <returns>
                previous value associated with
                <c>key</c>
                or
                <c>null</c>
                if there was no mapping for
                <c>key</c>
                .
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Put(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Puts an entry into this map with a given ttl (time to live) value.</summary>
            <remarks>
                Puts an entry into this map with a given ttl (time to live) value.
                Entry will expire and get evicted after the ttl. If ttl is 0, then
                the entry lives forever.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
                <p />
                <p>
                    <b>Warning-2:</b>
                </p>
                <p>
                    This method returns a clone of previous value, not the original (identically equal) value
                    previously put into map.
                </p>
            </remarks>
            <param name="key">key of the entry</param>
            <param name="value">value of the entry</param>
            <param name="ttl">maximum time for this entry to stay in the map, 0 means infinite.</param>
            <param name="timeunit"><see cref="T:Hazelcast.Core.TimeUnit" />for the ttl</param>
            <returns>old value of the entry</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.PutAll(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
                Copies all of the mappings from the specified map to this map
            </summary>
            <param name="m">mappings to be stored in this map</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.PutAsync(`0,`1)">
            <summary>Asynchronously puts the given key and value.</summary>
            <remarks>
                Asynchronously puts the given key and value.
                <code>
            Task&lt;V&gt; task = map.PutAsync(key, value);
            // do some other stuff, when ready get the result
            V oldValue = task.Result;
            </code>
                Task.Result will block until the actual map.Put() completes.
                If the application requires timely response,
                then task.Wait(timeout) can be used.
                <code>
            try
            {
                Task&lt;V&gt; task = map.PutAsync(key, value);
                if(task.Wait(TimeSpan.FromMilliseconds(40)))
                {
                   V value = task.Result; 
                }
                else
                {
                 //Result not ready
                }
            </code>
                ExecutionException is never thrown.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">the key of the map entry</param>
            <param name="value">the new value of the map entry</param>
            <returns>Task&lt;V&gt; from which the old value of the key can be retrieved.</returns>
            <seealso cref="T:System.Threading.Tasks.Task`1" />
        </member>
        <member name="M:Hazelcast.Core.IMap`2.PutAsync(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Asynchronously puts the given key and value into this map with a given ttl (time to live) value.</summary>
            <remarks>
                Asynchronously puts the given key and value into this map with a given ttl (time to live) value.
                Entry will expire and get evicted after the ttl. If ttl is 0, then
                the entry lives forever.
                <code>
            Task&lt;V&gt; task = map.PutAsync(key, value, ttl, timeunit);
            // do some other stuff, when ready get the result
            V oldValue = task.Result;
            </code>
                Task.Result will block until the actual map.Put() completes.
                If the application requires timely response,
                then task.Wait(timeout) can be used.
                <code>
            try
            {
                Task&lt;V&gt; task = map.PutAsync(key, value, ttl, timeunit);
                if(task.Wait(TimeSpan.FromMilliseconds(40)))
                {
                   V value = task.Result; 
                }
                else
                {
                 //Result not ready
                }
            </code>
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">the key of the map entry</param>
            <param name="value">the new value of the map entry</param>
            <param name="ttl">
                maximum time for this entry to stay in the map
                0 means infinite.
            </param>
            <param name="timeunit">time unit for the ttl</param>
            <returns>Task&lt;V&gt; from which the old value of the key can be retrieved.</returns>
            <seealso cref="T:System.Threading.Tasks.Task`1" />
        </member>
        <member name="M:Hazelcast.Core.IMap`2.PutIfAbsent(`0,`1)">
            <summary>
                If the specified key is not already associated
                with a value, associate it with the given value.
            </summary>
            <remarks>
                If the specified key is not already associated
                with a value, associate it with the given value.
                This is equivalent to
                <code>
            if (!map.ContainsKey(key))
                return map.Put(key, value);
            else
                return map.Get(key);
            </code>
                except that the action is performed atomically.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
                <p />
                <p>
                    <b>Warning-2:</b>
                </p>
                <p>
                    This method returns a clone of previous value, not the original (identically equal) value
                    previously put into map.
                </p>
            </remarks>
            <param name="key">key</param>
            <param name="value">value</param>
            <returns> previous value associated with <c>key</c> or <c>null</c> if there was no mapping for <c>key</c> .</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.PutIfAbsent(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
                Puts an entry into this map with a given ttl (time to live) value
                if the specified key is not already associated with a value.
            </summary>
            <remarks>
                Puts an entry into this map with a given ttl (time to live) value
                if the specified key is not already associated with a value.
                Entry will expire and get evicted after the ttl.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
                <p />
                <p>
                    <b>Warning-2:</b>
                </p>
                <p>
                    This method returns a clone of previous value, not the original (identically equal) value
                    previously put into map.
                </p>
            </remarks>
            <param name="key">key of the entry</param>
            <param name="value">value of the entry</param>
            <param name="ttl">maximum time for this entry to stay in the map</param>
            <param name="timeunit"><see cref="T:Hazelcast.Core.TimeUnit" /> for the timeout</param>
            <returns>old value of the entry</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.PutTransient(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
                Same as <see cref="!:IMap&lt;K, V&gt;.Put(TKey, TValue, long, TimeUnit)" />
                but MapStore, if defined,
                will not be called to store/persist the entry.  If ttl is 0, then
                the entry lives forever.
            </summary>
            <remarks>
                Same as <see cref="!:IMap&lt;K, V&gt;.Put(TKey, TValue, long, TimeUnit)" />
                but MapStore, if defined,
                will not be called to store/persist the entry.  If ttl is 0, then
                the entry lives forever.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key of the entry</param>
            <param name="value">value of the entry</param>
            <param name="ttl">
                maximum time for this entry to stay in the map.
                0 means infinite.
            </param>
            <param name="timeunit"><see cref="T:Hazelcast.Core.TimeUnit" /> for the ttl</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Remove(System.Object)">
            <summary>Removes the mapping for a key from this map if it is present.</summary>
            <remarks>
                Removes the mapping for a key from this map if it is present.
                <p>
                    The map will not contain a mapping for the specified key once the call returns.
                </p>
            </remarks>
            <param name="key">key</param>
            <returns>
                previous value associated with <c>key</c> or <c>null</c>
                if there was no mapping for <c>key</c> .
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Remove(System.Object,System.Object)">
            <summary>Removes the entry for a key only if currently mapped to a given value.</summary>
            <remarks>
                Removes the entry for a key only if currently mapped to a given value.
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
                <p />
            </remarks>
            <param name="key">key</param>
            <param name="value">value</param>
            <returns><c>true</c> if the value was removed </returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.RemoveAsync(`0)">
            <summary>Asynchronously removes the given key.</summary>
            <remarks>
                Asynchronously removes the given key.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">The key of the map entry to remove.</param>
            <returns>Task&lt;V&gt; from which the value removed from the map can be retrieved.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.RemoveEntryListener(System.String)">
            <summary>
                Removes the specified entry listener
                Returns silently if there is no such listener added before.
            </summary>
            <remarks>
                Removes the specified entry listener
                Returns silently if there is no such listener added before.
            </remarks>
            <param name="id">id of registered listener</param>
            <returns>true if registration is removed, false otherwise</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.RemoveInterceptor(System.String)">
            <summary>Removes the given interceptor for this map.</summary>
            <remarks>
                Removes the given interceptor for this map. So it will not intercept operations anymore.
            </remarks>
            <param name="id">registration id of map interceptor</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.RemoveAll(Hazelcast.Core.IPredicate)">
             <summary>
             Removes all entries which match with the supplied predicate.
             </summary>
             <remarks>
             If this map has index, matching entries will be found via index search, otherwise they will be found by full-scan.
            
             Note that calling this method also removes all entries from callers near cache.
             </remarks>
             <param name="predicate">matching entries with this predicate will be removed from this map</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Replace(`0,`1)">
            <summary>Replaces the entry for a key only if currently mapped to some value.</summary>
            <remarks>
                Replaces the entry for a key only if currently mapped to some value.
                This is equivalent to
                <code>
            if (map.ContainsKey(key))
                return map.put(key, value);
            else 
                return null;
            </code>
                >
                except that the action is performed atomically.
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key</param>
            <param name="value">value</param>
            <returns> previous value associated with <c>key</c> or <c>null</c> if there was no mapping for <c>key</c> . </returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Replace(`0,`1,`1)">
            <summary>Replaces the entry for a key only if currently mapped to a given value.</summary>
            <remarks>
                Replaces the entry for a key only if currently mapped to a given value.
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key</param>
            <param name="oldValue">old value</param>
            <param name="newValue">new value</param>
            <returns><c>true</c> if the value was replaced </returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Set(`0,`1)">
            <summary>Puts an entry into this map.</summary>
            <remarks>
                Puts an entry into this map.
                Similar to <see cref="M:Hazelcast.Core.IMap`2.Put(`0,`1)" /> operation except that <c>Set</c>
                doesn't return the old value which is more efficient.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key of the entry</param>
            <param name="value">value of the entry</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Set(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Puts an entry into this map with a given ttl (time to live) value.</summary>
            <remarks>
                Puts an entry into this map with a given ttl (time to live) value.
                Similar to put operation except that set
                doesn't return the old value which is more efficient.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key of the entry</param>
            <param name="value">value of the entry</param>
            <param name="ttl"> maximum time to wait for acquiring the lock for the key </param>
            <param name="timeunit"><see cref="T:Hazelcast.Core.TimeUnit" /> for the ttl</param>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Size">
            <summary>Returns the number of entries in this map.</summary>
            <remarks>Returns the number of entries in this map.</remarks>
            <returns>the number of entries in this map</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.SubmitToKey(`0,Hazelcast.Map.IEntryProcessor)">
            <summary>
            Applies the user defined EntryProcessor to the entry mapped by the key.
            Returns immediately with a Task.
            </summary>
            <param name="key">key to be processed</param>
            <param name="entryProcessor">
                The user defined <see cref="T:Hazelcast.Map.IEntryProcessor"/>. This object must have a hazelcast serializable
                EntryProcessor counterpart registered on server side with the actual
                <c>org.hazelcast.map.EntryProcessor</c> implementation.
            </param>
            <returns>the results mapped by each key in the collection</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.TryLock(`0)">
            <summary>Tries to acquire the lock for the specified key.</summary>
            <remarks>
                Tries to acquire the lock for the specified key.
                <p>
                    If the lock is not available then the current thread
                    doesn't wait and returns false immediately.
                </p>
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key to lock.</param>
            <returns><c>true</c> if lock is acquired, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.TryLock(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Tries to acquire the lock for the specified key.</summary>
            <remarks>
                Tries to acquire the lock for the specified key.
                <p>
                    If the lock is not available then
                    the current thread becomes disabled for thread scheduling
                    purposes and lies dormant until one of two things happens:
                    <ul>
                        <li>The lock is acquired by the current thread; or</li>
                        <li>The specified waiting time elapses</li>
                    </ul>
                </p>
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key to lock in this map</param>
            <param name="time">maximum time to wait for the lock</param>
            <param name="timeunit"><see cref="T:Hazelcast.Core.TimeUnit" /> for the ttl</param>
            <returns><c>true</c> if lock is acquired, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.TryLock(`0,System.Int64,Hazelcast.Core.TimeUnit,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Tries to acquire the lock for the specified key for the specified lease time.</summary>
            <remarks>
                Tries to acquire the lock for the specified key for the specified lease time.
                <p>
                    After lease time, the lock will be released.
                    <p />
                    <p>
                        If the lock is not available, then
                        the current thread becomes disabled for thread scheduling
                        purposes and lies dormant until one of two things happens:
                        <ul>
                            <li>
                                the lock is acquired by the current thread, or</li>
                                <li>the specified waiting time elapses.</li>
                        </ul>
                        <p />
                        <p>
                            <b>Warning:</b>
                        </p>
                        This method uses <tt>hashCode</tt> and <tt>equals</tt> of the binary form of
                        the <tt>key</tt>, not the actual implementations of <tt>hashCode</tt> and <tt>equals</tt>
                        defined in the <tt>key</tt>'s class.
                    </p>
                </p>
            </remarks>
            <param name="key">key to lock in this map.</param>
            <param name="time">maximum time to wait for the lock.</param>
            <param name="timeunit">time unit of the <tt>time</tt> argument.</param>
            <param name="leaseTime">time to wait before releasing the lock.</param>
            <param name="leaseTimeunit">unit of time to specify lease time.</param>
            <returns>
                <tt>true</tt> if the lock was acquired and <tt>false</tt>
                if the waiting time elapsed before the lock was acquired.
            </returns>
            <exception cref="T:System.ArgumentNullException">if the specified key is null.</exception>
            <exception cref="T:System.Exception" />
        </member>
        <member name="M:Hazelcast.Core.IMap`2.TryPut(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
                Tries to put the given key, value into this map within specified timeout value.
            </summary>
            <remarks>
                Tries to put the given key, value into this map within specified
                timeout value. If this method returns false, it means that
                the caller thread couldn't acquire the lock for the key within
                timeout duration, thus put operation is not successful.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key of the entry</param>
            <param name="value">value of the entry</param>
            <param name="timeout">maximum time to wait</param>
            <param name="timeunit"><see cref="T:Hazelcast.Core.TimeUnit" /> for the timeout</param>
            <returns> <c>true</c> if the put is successful, <c>false</c> otherwise. </returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.TryRemove(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
                Tries to remove the entry with the given key from this map
                within specified timeout value.
            </summary>
            <remarks>
                Tries to remove the entry with the given key from this map
                within specified timeout value. If the key is already locked by another
                thread and/or member, then this operation will wait timeout
                amount for acquiring the lock.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
                <p />
                <p>
                    <b>Warning-2:</b>
                </p>
                <p>
                    This method returns a clone of previous value, not the original (identically equal) value
                    previously put into map.
                </p>
            </remarks>
            <param name="key">key of the entry</param>
            <param name="timeout"> maximum time to wait for acquiring the lock for the key </param>
            <param name="timeunit"><see cref="T:Hazelcast.Core.TimeUnit" /> for the ttl</param>
            <returns> <c>true</c> if the remove is successful, <c>false</c> otherwise. </returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Unlock(`0)">
            <summary>Releases the lock for the specified key.</summary>
            <remarks>
                Releases the lock for the specified key. It never blocks and
                returns immediately.
                <p />
                <p>
                    If the current thread is the holder of this lock then the hold
                    count is decremented.  If the hold count is now zero then the lock
                    is released.  If the current thread is not the holder of this
                    lock then <see cref="T:System.Threading.SynchronizationLockException" /> is thrown.
                </p>
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                This method uses <c>GetHashCode</c> and <c>Equals</c> of binary form of
                the <c>key</c>, not the actual implementations of <c>GetHashCode</c> and <c>Equals</c>
                defined in <c>key</c>'s class.
            </remarks>
            <param name="key">key to lock.</param>
            <exception cref="T:System.Threading.SynchronizationLockException">if the current thread does not hold this lock</exception>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Values">
            <summary>Returns a collection clone of the values contained in this map.</summary>
            <remarks>
                Returns a collection clone of the values contained in this map.
                The collection is <b>NOT</b> backed by the map,
                so changes to the map are <b>NOT</b> reflected in the collection, and vice-versa.
            </remarks>
            <returns>a collection clone of the values contained in this map</returns>
        </member>
        <member name="M:Hazelcast.Core.IMap`2.Values(Hazelcast.Core.IPredicate)">
            <summary>
                Queries the map based on the specified predicate and
                returns the values of matching entries.
            </summary>
            <remarks>
                Queries the map based on the specified predicate and
                returns the values of matching entries.
                <p />
                Specified predicate runs on all members in parallel.
                <p />
                <p>
                    <b>Warning:</b>
                </p>
                The collection is <b>NOT</b> backed by the map,
                so changes to the map are <b>NOT</b> reflected in the collection, and vice-versa.
            </remarks>
            <param name="predicate">query criteria</param>
            <returns>result value collection of the query</returns>
        </member>
        <member name="T:Hazelcast.Core.IMultiMap`2">
            <summary>A specialized Concurrent, distributed map whose keys can be associated with multiple values.</summary>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.AddEntryListener(Hazelcast.Core.IEntryListener{`0,`1},System.Boolean)">
            <summary>Adds an entry listener for this multimap.</summary>
            <param name="listener">entry listener</param>
            <param name="includeValue">
                <c>true</c> if <c>EntryEvent</c> should
                contain the value.
            </param>
            <returns>returns registration id.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.AddEntryListener(Hazelcast.Core.IEntryListener{`0,`1},`0,System.Boolean)">
            <summary>Adds the specified entry listener for the specified key.</summary>
            <param name="listener">entry listener</param>
            <param name="key">the key to listen</param>
            <param name="includeValue">
                <c>true</c> if <c>EntryEvent</c> should
                contain the value.
            </param>
            <returns>returns registration id.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Clear">
            <summary>Clears the multimap.</summary>
            <remarks>Clears the multimap. Removes all key-value pairs.</remarks>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.ContainsEntry(`0,`1)">
            <summary>Returns whether the multimap contains the given key-value pair.</summary>
            <param name="key">the key whose existence is checked.</param>
            <param name="value">the value whose existence is checked.</param>
            <returns>true if the multimap contains the key-value pair, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.ContainsKey(`0)">
            <summary>Returns whether the multimap contains an entry with the key.</summary>
            <param name="key">the key whose existence is checked.</param>
            <returns>true if the multimap contains an entry with the key, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.ContainsValue(System.Object)">
            <summary>Returns whether the multimap contains an entry with the value.</summary>
            <param name="value">the value whose existence is checked.</param>
            <returns>true if the multimap contains an entry with the value, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.EntrySet">
            <summary>Returns the set of key-value pairs in the multimap.</summary>
            <returns>
                the set of key-value pairs in the multimap. Returned set might be modifiable
                but it has no effect on the multimap
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.ForceUnlock(`0)">
            <summary>Releases the lock for the specified key regardless of the lock owner.</summary>
            <param name="key">key to lock.</param>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Get(`0)">
            <summary>Returns the collection of values associated with the key.</summary>
            <param name="key">the key whose associated values are to be returned</param>
            <returns>the collection of the values associated with the key.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.IsLocked(`0)">
            <summary>Checks the lock for the specified key.</summary>
            <param name="key">key to lock to be checked.</param>
            <returns><c>true</c> if lock is acquired, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.KeySet">
            <summary>Returns the set of keys in the multimap.</summary>
            <returns>
                the set of keys in the multimap. Returned set might be modifiable
                but it has no effect on the multimap
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Lock(`0)">
            <summary>Acquires the lock for the specified key.</summary>
            <param name="key">key to lock.</param>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Lock(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Acquires the lock for the specified key for the specified lease time.</summary>
            <param name="key">key to lock.</param>
            <param name="leaseTime">time to wait before releasing the lock.</param>
            <param name="timeUnit">unit of time to specify lease time.</param>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Put(`0,`1)">
            <summary>Stores a key-value pair in the multimap.</summary>
            <param name="key">the key to be stored</param>
            <param name="value">the value to be stored</param>
            <returns>
                true if size of the multimap is increased, false if the multimap
                already contains the key-value pair.
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Remove(System.Object,System.Object)">
            <summary>Removes the given key value pair from the multimap.</summary>
            <param name="key">the key of the entry to remove</param>
            <param name="value">the value of the entry to remove</param>
            <returns>true if the size of the multimap changed after the remove operation, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Remove(System.Object)">
            <summary>Removes all the entries with the given key.</summary>
            <param name="key">the key of the entries to remove</param>
            <returns>
                the collection of removed values associated with the given key. Returned collection
                might be modifiable but it has no effect on the multimap
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.RemoveEntryListener(System.String)">
            <summary>
                Removes the specified entry listener
                Returns silently if there is no such listener added before.
            </summary>
            <param name="registrationId">Id of listener registration</param>
            <returns>true if registration is removed, false otherwise</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Size">
            <summary>Returns the number of key-value pairs in the multimap.</summary>
            <returns>the number of key-value pairs in the multimap.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.TryLock(`0)">
            <summary>Tries to acquire the lock for the specified key.</summary>
            <param name="key">key to lock.</param>
            <returns><c>true</c> if lock is acquired, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.TryLock(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Tries to acquire the lock for the specified key.</summary>
            <param name="key">the key to lock</param>
            <param name="time">the maximum time to wait for the lock</param>
            <param name="timeunit">the time unit of the <c>time</c> argument.</param>
            <returns>
                <c>true</c> if the lock was acquired and <c>false</c>
                if the waiting time elapsed before the lock was acquired.
            </returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.TryLock(`0,System.Int64,Hazelcast.Core.TimeUnit,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Tries to acquire the lock for the specified key for the specified lease time.</summary>
            <remarks>
            Tries to acquire the lock for the specified key for the specified lease time.
            <p>After lease time, the lock will be released.
            <p/>
            <p>If the lock is not available, then
            the current thread becomes disabled for thread scheduling
            purposes and lies dormant until one of two things happens:</p>
            <ul>
            <li>the lock is acquired by the current thread, or</li>
            <li>the specified waiting time elapses.</li>
            </ul>
            </p>
            <p/>
            <p><b>Warning:</b></p>
            This method uses <tt>hashCode</tt> and <tt>equals</tt> of the binary form of
            the <tt>key</tt>, not the actual implementations of <tt>hashCode</tt> and <tt>equals</tt>
            defined in the <tt>key</tt>'s class.
            </remarks>
            <param name="key">key to lock in this map.</param>
            <param name="time">maximum time to wait for the lock.</param>
            <param name="timeunit">time unit of the <tt>time</tt> argument.</param>
            <param name="leaseTime">time to wait before releasing the lock.</param>
            <param name="leaseTimeunit">unit of time to specify lease time.</param>
            <returns>
            <tt>true</tt> if the lock was acquired and <tt>false</tt>
            if the waiting time elapsed before the lock was acquired.
            </returns>
            <exception cref="T:System.ArgumentNullException">if the specified key is null.</exception>
            <exception cref="T:System.Exception"/>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Unlock(`0)">
            <summary>Releases the lock for the specified key.</summary>
            <param name="key">key to lock.</param>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.ValueCount(`0)">
            <summary>Returns number of values matching to given key in the multimap.</summary>
            <param name="key">the key whose values count are to be returned</param>
            <returns>number of values matching to given key in the multimap.</returns>
        </member>
        <member name="M:Hazelcast.Core.IMultiMap`2.Values">
            <summary>Returns the collection of values in the multimap.</summary>
            <returns>
                the collection of values in the multimap. Returned collection might be modifiable
                but it has no effect on the multimap
            </returns>
        </member>
        <member name="T:Hazelcast.Core.IQueue`1">
            <summary>Concurrent, blocking, distributed, observable queue.</summary>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.DrainTo``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Removes all available elements from this queue and adds them
            to the given collection.  This operation may be more
            efficient than repeatedly polling this queue.  A failure
            encountered while attempting to add elements to
            collection <c>c</c> may result in elements being in neither,
            either or both collections when the associated exception is
            thrown.  Attempts to drain a queue to itself result in
            <c>IllegalArgumentException</c>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </summary>
            <typeparam name="TE">type of elements</typeparam>
            <param name="c">the collection to transfer elements into</param>
            <returns>the number of elements transferred</returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.DrainTo``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>
            Removes at most the given number of available elements from
            this queue and adds them to the given collection.  A failure
            encountered while attempting to add elements to
            collection <c>c</c> may result in elements being in neither,
            either or both collections when the associated exception is
            thrown.  Attempts to drain a queue to itself result in
            <c>IllegalArgumentException</c>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </summary>
            <typeparam name="TE">type of elements</typeparam>
            <param name="c">the collection to transfer elements into</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <returns>the number of elements transferred</returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Element">
            <summary>
            Retrieves, but does not remove, the head of this queue.  This method
            differs from <see cref="M:Hazelcast.Core.IQueue`1.Peek"/> only in that it throws an exception
            if this queue is empty.
            </summary>
            <returns>the head of this queue</returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Offer(`0)">
            <summary>
            Inserts the specified element into this queue if it is possible to do
            so immediately without violating capacity restrictions, returning
            <c>true</c> upon success and <c>false</c> if no space is currently
            available.
            </summary>
            <remarks>
            Inserts the specified element into this queue if it is possible to do
            so immediately without violating capacity restrictions, returning
            <c>true</c> upon success and <c>false</c> if no space is currently
            available.
            </remarks>
            <param name="e">the element to add</param>
            <returns>
            <c>true</c> if the element was added to this queue, else
            <c>false</c>
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Offer(`0,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
            Inserts the specified element into this queue, waiting up to the
            specified wait time if necessary for space to become available.
            </summary>
            <remarks>
            Inserts the specified element into this queue, waiting up to the
            specified wait time if necessary for space to become available.
            </remarks>
            <param name="e">the element to add</param>
            <param name="timeout">
            how long to wait before giving up, in units of
            <c>unit</c>
            </param>
            <param name="unit">
            a <c>TimeUnit</c> determining how to interpret the
            <c>timeout</c> parameter
            </param>
            <returns>
            <c>true</c> if successful, or <c>false</c> if
            the specified waiting time elapses before space is available
            </returns>
            <exception cref="T:System.Exception">if interrupted while waiting</exception>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Poll">
            <summary>
            Retrieves and removes the head of this queue,
            or returns <c>null</c> if this queue is empty.
            </summary>
            <remarks>
            Retrieves and removes the head of this queue,
            or returns <c>null</c> if this queue is empty.
            </remarks>
            <returns>the head of this queue, or <c>null</c> if this queue is empty</returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Poll(System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
            Retrieves and removes the head of this queue, waiting up to the
            specified wait time if necessary for an element to become available.
            </summary>
            <remarks>
            Retrieves and removes the head of this queue, waiting up to the
            specified wait time if necessary for an element to become available.
            </remarks>
            <param name="timeout">
            how long to wait before giving up, in units of
            <c>unit</c>
            </param>
            <param name="unit">
            a <c>TimeUnit</c> determining how to interpret the
            <c>timeout</c> parameter
            </param>
            <returns>
            the head of this queue, or <c>null</c> if the
            specified waiting time elapses before an element is available
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Put(`0)">
            <summary>
            Inserts the specified element into this queue, waiting if necessary for space to become available.
            </summary>
            <param name="e">the element to add</param>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.RemainingCapacity">
             <summary>
             Returns the number of additional elements that this queue can ideally
             (in the absence of memory or resource constraints) accept without
             blocking, or <c>Int64.MaxValue</c> if there is no intrinsic
             limit.
            
             <p>Note that you <em>cannot</em> always tell if an attempt to insert
             an element will succeed by inspecting <c>remainingCapacity</c>
             because it may be the case that another thread is about to
             insert or remove an element.
            </p>
            </summary>
            <returns>the remaining capacity </returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Remove(System.Object)">
            <summary>
            Removes a single instance of the specified element from this queue, if it is present
            </summary>
            <param name="o">element to be removed from this queue, if present</param>
            <returns><c>true</c> if this queue changed as a result of the call, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Remove">
            <summary>
            Retrieves and removes the head of this queue.  This method differs
            from <see cref="M:Hazelcast.Core.IQueue`1.Poll"/> only in that it throws an exception if this
            queue is empty.
            </summary>
            <returns>the head of this queue</returns>
        </member>
        <member name="M:Hazelcast.Core.IQueue`1.Take">
            <summary>
            Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
            </summary>
            <remarks>
            Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
            </remarks>
            <returns>the head of this queue</returns>
        </member>
        <member name="T:Hazelcast.Core.IHSet`1">
            <summary>
                Concurrent, distributed implementation of ISet
            </summary>
            <remarks>
                <b>
                    This class is <i>not</i> a general-purpose <tt>ISet</tt> implementation! While this class implements
                    the <tt>Set</tt> interface, it intentionally violates <tt>Set's</tt> general contract, which mandates the
                    use of the <tt>Equals</tt> method when comparing objects. Instead of the equals method this implementation
                    compares the serialized byte version of the objects.
                </b>
            </remarks>
        </member>
        <member name="T:Hazelcast.Core.IRingbuffer`1">
            <summary>A Ringbuffer is a data-structure where the content is stored in a ring like structure.</summary>
            <remarks>
            A Ringbuffer is a data-structure where the content is stored in a ring like structure. A ringbuffer has a capacity so it
            won't grow beyond that capacity and endanger the stability of the system. If that capacity is exceeded, than the oldest
            item in the ringbuffer is overwritten.
            The ringbuffer has 2 always incrementing sequences:
            <ol>
            <li>
            tailSequence: this is the side where the youngest item is found. So the tail is the side of the ringbuffer where
            items are added to.
            </li>
            <li>
            headSequence: this is the side where the oldest items are found. So the head is the side where items gets
            discarded.
            </li>
            </ol>
            The items in the ringbuffer can be found by a sequence that is in between (inclusive) the head and tail sequence.
            If data is read from a ringbuffer with a sequence that is smaller than the headSequence, it means that the data
            is not available anymore and a
            <see cref="T:Hazelcast.Core.StaleSequenceException"/>
            is thrown.
            A Ringbuffer currently is not a distributed data-structure. So all data is stored in a single partition; comparable to the
            IQueue implementation. But we'll provide an option to partition the data in the near future.
            A Ringbuffer can be used in a similar way as a queue, but one of the key differences is that a queue.take is destructive,
            meaning that only 1 thread is able to take an item. A ringbuffer.read is not destructive, so you can have multiple threads
            reading the same item multiple times.
            The Ringbuffer is the backing data-structure for the reliable
            <see cref="T:Hazelcast.Core.ITopic`1"/>
            implementation.     
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.Add(`0)">
            <summary>Adds an item to the tail of the Ringbuffer.</summary>
            <remarks>
            Adds an item to the tail of the Ringbuffer. If there is no space in the Ringbuffer, the add will overwrite the oldest
            item in the ringbuffer no matter what the ttl is. For more control on this behavior, check the
            <see cref="M:Hazelcast.Core.IRingbuffer`1.AddAsync(`0,Hazelcast.Core.OverflowPolicy)"/>
            and the
            <see cref="T:Hazelcast.Core.OverflowPolicy"/>
            .
            The returned value is the sequence of the added item. Using this sequence you can read the added item.
            <h3>Using the sequence as id</h3>
            This sequence will always be unique for this Ringbuffer instance so it can be used as a unique id generator if you are
            publishing items on this Ringbuffer. However you need to take care of correctly determining an initial id when any node
            uses the ringbuffer for the first time. The most reliable way to do that is to write a dummy item into the ringbuffer and
            use the returned sequence as initial id. On the reading side, this dummy item should be discard. Please keep in mind that
            this id is not the sequence of the item you are about to publish but from a previously published item. So it can't be used
            to find that item.
            </remarks>
            <param name="item">the item to add.</param>
            <returns>the sequence of the added item.</returns>
            <exception cref="T:System.ArgumentNullException">if item is null.</exception>
            <seealso cref="M:Hazelcast.Core.IRingbuffer`1.AddAsync(`0,Hazelcast.Core.OverflowPolicy)"/>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.AddAllAsync``1(System.Collections.Generic.ICollection{``0},Hazelcast.Core.OverflowPolicy)">
            <summary>Adds all the items of a collection to the tail of the Ringbuffer.</summary>
            <remarks>
            Adds all the items of a collection to the tail of the Ringbuffer.
            A addAll is likely to outperform multiple calls to
            <see cref="M:Hazelcast.Core.IRingbuffer`1.Add(`0)"/>
            due to better io utilization and a reduced number
            of executed operations.
            If the batch is empty, the call is ignored.
            When the collection is not empty, the content is copied into a different data-structure. This means that:
            <ol>
            <li>after this call completes, the collection can be re-used.</li>
            <li>the collection doesn't need to be serializable</li>
            </ol>
            If the collection is larger than the capacity of the ringbuffer, then the items that were written first will
            be overwritten. Therefor this call will not block.
            The items are inserted in the order of the Iterator of the collection. If an addAll is executed concurrently with
            an add or addAll, no guarantee is given that items are contiguous.
            The result of the future contains the sequenceId of the last written item
            </remarks>
            <param name="collection">the batch of items to add.</param>
            <param name="overflowPolicy">overflow policy to use</param>
            <returns>the ICompletableFuture to synchronize on completion.</returns>
            <exception cref="T:System.ArgumentNullException">
            if batch is null,
            or if an item in this batch is null
            or if overflowPolicy is null
            </exception>
            <exception cref="T:System.ArgumentException">if collection is empty</exception>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.AddAsync(`0,Hazelcast.Core.OverflowPolicy)">
            <summary>
            Asynchronously writes an item with a configurable
            <see cref="T:Hazelcast.Core.OverflowPolicy"/>
            .
            If there is space in the ringbuffer, the call will return the sequence of the written item.
            If there is no space, it depends on the overflow policy what happens:
            <ol>
            <li>
            <see cref="F:Hazelcast.Core.OverflowPolicy.Overwrite"/>
            : we just overwrite the oldest item in the ringbuffer and we violate
            the ttl</li>
            <li>
            <see cref="F:Hazelcast.Core.OverflowPolicy.Fail"/>
            : we return -1 </li>
            </ol>
            The reason that FAIL exist is to give the opportunity to obey the ttl. If blocking behavior is required,
            this can be implemented using retrying in combination with a exponential backoff. Example:
            <code>
            int sleepMs = 100;
            for (; ; ) {
            long result = ringbuffer.AddAsync(item, OverflowPolicy.Fail).Result;
            if (result != -1) {
            break;
            }
            Thread.Sleep(sleepMs);
            sleepMs = Math.Min(5000, sleepMs * 2);
            }
            </code>
            </summary>
            <param name="item">the item to add</param>
            <param name="overflowPolicy">the OverflowPolicy to use.</param>
            <returns>the sequenceId of the added item, or -1 if the add failed.</returns>
            <exception cref="T:System.ArgumentNullException">if item or overflowPolicy is null.</exception>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.Capacity">
            <summary>Returns the capacity of this Ringbuffer.</summary>
            <returns>the capacity.</returns>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.HeadSequence">
            <summary>Returns the sequence of the head.</summary>
            <remarks>
            Returns the sequence of the head. The head is the side of the ringbuffer where the oldest items in the
            ringbuffer are found.
            If the RingBuffer is empty, the head will be one more than the tail.
            The initial value of the head is 0 (1 more than tail).
            </remarks>
            <returns>the sequence of the head.</returns>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.ReadManyAsync(System.Int64,System.Int32,System.Int32)">
            <summary>Reads a batch of items from the Ringbuffer.</summary>
            <remarks>
            Reads a batch of items from the Ringbuffer. If the number of available items after the first read item is smaller than
            the maxCount, these items are returned. So it could be the number of items read is smaller than the maxCount.
            If there are less items available than minCount, then this call blocks.
            Reading a batch of items is likely to perform better because less overhead is involved.
            </remarks>
            <param name="startSequence">the startSequence of the first item to read.</param>
            <param name="minCount">the minimum number of items to read.</param>
            <param name="maxCount">the maximum number of items to read.</param>
            <returns>a future containing the items read.</returns>
            <exception cref="T:System.ArgumentException">
            if startSequence is smaller than 0
            or if startSequence larger than
            <see cref="M:Hazelcast.Core.IRingbuffer`1.TailSequence"/>
            or if minCount smaller than 0
            or if minCount larger than maxCount,
            or if maxCount larger than the capacity of the ringbuffer
            or if maxCount larger than 1000 (to prevent overload)
            </exception>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.ReadOne(System.Int64)">
            <summary>Reads one item from the Ringbuffer.</summary>
            <remarks>
            Reads one item from the Ringbuffer.
            If the sequence is one beyond the current tail, this call blocks until an item is added.
            This means that the ringbuffer can be processed using the following idiom:
            <code>
            Ringbuffer&lt;String&gt; ringbuffer = hz.GetRingbuffer("rb");
            long seq = ringbuffer.HeadSequence();
            while(true){
            String item = ringbuffer.ReadOne(seq);
            seq++;
            ... process item
            }
            </code>
            This method is not destructive unlike e.g. a queue.take. So the same item can be read by multiple readers or it can be
            read multiple times by the same reader.
            Currently it isn't possible to control how long this call is going to block. In the future we could add e.g.
            tryReadOne(long sequence, long timeout, TimeUnit unit).
            </remarks>
            <param name="sequence">the sequence of the item to read.</param>
            <returns>the read item</returns>
            <exception cref="T:Hazelcast.Core.StaleSequenceException">
            if the sequence is smaller then
            <see cref="M:Hazelcast.Core.IRingbuffer`1.HeadSequence"/>
            . Because a
            Ringbuffer won't store all event indefinitely, it can be that the data for the
            given sequence doesn't exist anymore and the
            <see cref="T:Hazelcast.Core.StaleSequenceException"/>
            is thrown. It is up to the caller to deal with this particular situation, e.g.
            throw an Exception or restart from the last known head. That is why the
            StaleSequenceException contains the last known head.
            </exception>
            <exception cref="T:System.ArgumentException">
            if sequence is smaller than 0 or larger than
            <see cref="M:Hazelcast.Core.IRingbuffer`1.TailSequence"/>
            +1.
            </exception>
            <exception cref="T:System.Exception">if the call is interrupted while blocking.</exception>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.RemainingCapacity">
            <summary>Returns the remaining capacity of the ringbuffer.</summary>
            <remarks>
            Returns the remaining capacity of the ringbuffer.
            The returned value could be stale as soon as it is returned.
            If ttl is not set, the remaining capacity will always be the capacity.
            </remarks>
            <returns>the remaining capacity.</returns>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.Size">
            <summary>Returns number of items in the ringbuffer.</summary>
            <remarks>
            Returns number of items in the ringbuffer.
            If no ttl is set, the size will always be equal to capacity after the head completed the first loop
            around the ring. This is because no items are getting retired.
            </remarks>
            <returns>the size.</returns>
        </member>
        <member name="M:Hazelcast.Core.IRingbuffer`1.TailSequence">
            <summary>Returns the sequence of the tail.</summary>
            <remarks>
            Returns the sequence of the tail. The tail is the side of the ringbuffer where the items are added to.
            The initial value of the tail is -1.
            </remarks>
            <returns>the sequence of the tail.</returns>
        </member>
        <member name="T:Hazelcast.Core.ITopic`1">
            <summary>
                Hazelcast provides distribution mechanism for publishing messages that are delivered to multiple subscribers
                which is also known as publish/subscribe (pub/sub) messaging model.
            </summary>
            <remarks>
                <p>Hazelcast provides distribution mechanism for publishing messages that are delivered to multiple subscribers
                which is also known as publish/subscribe (pub/sub) messaging model. Publish and subscriptions are cluster-wide.
                When a member subscribes for a topic, it is actually registering for messages published by any member in the
                cluster,
                including the new members joined after you added the listener.
                </p>
                Messages are ordered, meaning, listeners(subscribers)
                will process the messages in the order they are actually published. If cluster member M publishes messages
                m1, m2, m3...mn to a topic T, then Hazelcast makes sure that all of the subscribers of topic T will receive
                and process m1, m2, m3...mn in order.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.ITopic`1.AddMessageListener(Hazelcast.Core.IMessageListener{`0})">
            <summary>Subscribes to this topic.</summary>
            <remarks>
                Subscribes to this topic. When someone publishes a message on this topic.
                onMessage() function of the given IMessageListener is called. More than one message listener can be
                added on one instance.
            </remarks>
            <param name="listener"></param>
            <returns>returns registration id.</returns>
        </member>
        <member name="M:Hazelcast.Core.ITopic`1.AddMessageListener(System.Action{Hazelcast.Core.Message{`0}})">
            <summary>Subscribes to this topic.</summary>
            <remarks>
                Subscribes to this topic. When someone publishes a message on this topic.
                onMessage() function of the given IMessageListener is called. More than one message listener can be
                added on one instance.
            </remarks>
            <param name="listener"></param>
        </member>
        <member name="M:Hazelcast.Core.ITopic`1.GetName">
            <summary>Returns the name of this ITopic instance</summary>
            <returns>name of this instance</returns>
        </member>
        <member name="M:Hazelcast.Core.ITopic`1.Publish(`0)">
            <summary>Publishes the message to all subscribers of this topic</summary>
            <param name="message"></param>
        </member>
        <member name="M:Hazelcast.Core.ITopic`1.RemoveMessageListener(System.String)">
            <summary>Stops receiving messages for the given message listener.</summary>
            <remarks>
                Stops receiving messages for the given message listener. If the given listener already removed,
                this method does nothing.
            </remarks>
            <param name="registrationId">Id of listener registration.</param>
            <returns>true if registration is removed, false otherwise</returns>
        </member>
        <member name="T:Hazelcast.Core.ITransactionalList`1">
            <summary>
            Transactional implementation of <see cref="T:Hazelcast.Core.IHList`1">IHList&lt;E&gt;</see>
            </summary>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalList`1.Add(`0)">
            <summary>Add new item to transactional list</summary>
            <param name="e">item</param>
            <returns>true if item is added successfully</returns>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalList`1.Remove(`0)">
            <summary>Add item from transactional list</summary>
            <param name="e">item</param>
            <returns>true if item is remove successfully</returns>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalList`1.Size">
            <summary>Returns the size of the list</summary>
            <returns>size</returns>
        </member>
        <member name="T:Hazelcast.Core.ITransactionalMap`2">
            <summary>
            Transactional implementation of Map
            </summary>
            <typeparam name="TKey">key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.ContainsKey(System.Object)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.ContainsKey(System.Object)"/>
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.ContainsKey(System.Object)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Delete(System.Object)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Delete(System.Object)"/>
            .
            <p/>
            The object to be deleted will be removed from only the current transaction context until the transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Delete(System.Object)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Get(System.Object)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Get(System.Object)"/>
            .
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Get(System.Object)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.GetForUpdate(System.Object)">
            <summary>Locks the key and then gets and returns the value to which the specified key is mapped.</summary>
            <remarks>
            Locks the key and then gets and returns the value to which the specified key is mapped.
            Lock will be released at the end of the transaction (either commit or rollback).
            </remarks>
            <seealso cref="M:Hazelcast.Core.IMap`2.Get(System.Object)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.IsEmpty">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.IsEmpty"/>
            .
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.IsEmpty"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.KeySet">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.KeySet"/>
            .
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.KeySet"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.KeySet(Hazelcast.Core.IPredicate)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.KeySet(Hazelcast.Core.IPredicate)"/>
            .
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.KeySet(Hazelcast.Core.IPredicate)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Put(`0,`1)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Put(`0,`1)"/>
            .
            <p/>
            The object to be put will be accessible only in the current transaction context till transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Put(`0,`1)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Put(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Put(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)"/>
            .
            <p/>
            The object to be put will be accessible only in the current transaction context till transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Put(`0,`1,System.Int64,Hazelcast.Core.TimeUnit)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.PutIfAbsent(`0,`1)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.PutIfAbsent(`0,`1)"/>
            .
            <p/>
            The object to be put will be accessible only in the current transaction context until the transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.PutIfAbsent(`0,`1)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Remove(System.Object)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Remove(System.Object)"/>
            .
            <p/>
            The object to be removed will be removed from only the current transaction context until the transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Remove(System.Object)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Remove(System.Object,System.Object)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Remove(System.Object,System.Object)"/>
            .
            <p/>
            The object to be removed will be removed from only the current transaction context until the transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Remove(System.Object,System.Object)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Replace(`0,`1)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Replace(`0,`1)"/>
            .
            <p/>
            The object to be replaced will be accessible only in the current transaction context until the transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Replace(`0,`1)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Replace(`0,`1,`1)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Replace(`0,`1,`1)"/>
            .
            <p/>
            The object to be replaced will be accessible only in the current transaction context until the transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Replace(`0,`1,`1)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Set(`0,`1)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Set(`0,`1)"/>
            .
            <p/>
            The object to be set will be accessible only in the current transaction context till transaction is committed.
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Set(`0,`1)"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Size">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Size"/>
            .
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Size"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Values">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Values"/>
            .
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Values"/>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalMap`2.Values(Hazelcast.Core.IPredicate)">
            <summary>
            Transactional implementation of
            <see cref="M:Hazelcast.Core.IMap`2.Values(Hazelcast.Core.IPredicate)"/>
            .
            </summary>
            <seealso cref="M:Hazelcast.Core.IMap`2.Values(Hazelcast.Core.IPredicate)"/>
        </member>
        <member name="T:Hazelcast.Core.ITransactionalMultiMap`2">
            <summary>Transactional implementation of MultiMap</summary>
        </member>
        <member name="T:Hazelcast.Core.ITransactionalQueue`1">
            <summary>Transactional implementation of Queue</summary>
        </member>
        <member name="T:Hazelcast.Core.ITransactionalSet`1">
            <summary>
                Transactional implementation of
                <see cref="T:Hazelcast.Core.IHSet`1">IHSet&lt;E&gt;</see>
                .
            </summary>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalSet`1.Add(`0)">
            <summary>Add new item to transactional set</summary>
            <param name="e">item</param>
            <returns>true if item is added successfully</returns>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalSet`1.Remove(`0)">
            <summary>Add item from transactional set</summary>
            <param name="e">item</param>
            <returns>true if item is remove successfully</returns>
        </member>
        <member name="M:Hazelcast.Core.ITransactionalSet`1.Size">
            <summary>Returns the size of the set</summary>
            <returns>size</returns>
        </member>
        <member name="M:Hazelcast.Core.MapEvent.GetNumberOfEntriesAffected">
            <summary>Returns the number of entries affected by this event.</summary>
            <returns>the number of entries affected</returns>
        </member>
        <member name="T:Hazelcast.Core.OverflowPolicy">
            <summary>
            Using this policy one can control the behavior what should to be done when an item is about to be added to the ringbuffer,
            but there is 0 remaining capacity.
            </summary>
            <remarks>
            Using this policy one can control the behavior what should to be done when an item is about to be added to the ringbuffer,
            but there is 0 remaining capacity.
            Overflowing happens when a time-to-live is set and the oldest item in the ringbuffer (the head) is not old enough to expire.
            </remarks>
            <seealso cref="M:Hazelcast.Core.IRingbuffer`1.AddAsync(`0,Hazelcast.Core.OverflowPolicy)"/>
            <seealso cref="M:Hazelcast.Core.IRingbuffer`1.AddAllAsync``1(System.Collections.Generic.ICollection{``0},Hazelcast.Core.OverflowPolicy)"/>
        </member>
        <member name="F:Hazelcast.Core.OverflowPolicy.Overwrite">
            <summary>Using this policy the oldest item is overwritten no matter it is not old enough to retire.</summary>
            <remarks>
            Using this policy the oldest item is overwritten no matter it is not old enough to retire. Using this policy you are
            sacrificing the time-to-live in favor of being able to write.
            Example: if there is a time-to-live of 30 seconds, the buffer is full and the oldest item in the ring has been placed a
            second ago, then there are 29 seconds remaining for that item. Using this policy you are going to overwrite no matter
            what.
            </remarks>
        </member>
        <member name="F:Hazelcast.Core.OverflowPolicy.Fail">
            <summary>
            Using this policy the call will fail immediately and the oldest item will not be overwritten before it is old enough
            to retire.
            </summary>
            <remarks>
            Using this policy the call will fail immediately and the oldest item will not be overwritten before it is old enough
            to retire. So this policy sacrificing the ability to write in favor of time-to-live.
            The advantage of fail is that the caller can decide what to do since it doesn't trap the thread due to backoff.
            Example: if there is a time-to-live of 30 seconds, the buffer is full and the oldest item in the ring has been placed a
            second ago, then there are 29 seconds remaining for that item. Using this policy you are not going to overwrite that
            item for the next 29 seconds.
            </remarks>
        </member>
        <member name="T:Hazelcast.Core.PagingPredicate">
             <summary>
             This class is a special Predicate which helps to get a page-by-page result of a query.
             It can be constructed with a page-size, an inner predicate for filtering, and a comparator for sorting.
             </summary>
             <remarks>
             This class is not thread-safe and stateless. To be able to reuse for another query, one should call
             <see cref="M:Hazelcast.Core.PagingPredicate.Reset"/>
             </remarks>
             <example>
             <code>
             Predicate lessEqualThanFour = Predicates.IsLessThanOrEqual("this", 4);
             // We are constructing our paging predicate with a predicate and page size. In this case query results fetched two by two.
             PagingPredicate predicate = new PagingPredicate(lessEqualThanFour, 2);
             // we are initializing our map with integers from 0 to 10 as keys and values.
             IMap map = hazelcastInstance.getMap("myMap");
             for (int i = 0; i &lt; 10; i++)
             {
                 map.Put(i, i);
             }
            
             //invoking the query
             var values = map.Values(predicate);
             Console.WriteLine("values = " + values); // will print 'values = [0, 1]'
             predicate.NextPage(); // we are setting up paging predicate to fetch next page in the next call.
             values = map.Values(predicate);
             Console.WriteLine("values = " + values);// will print 'values = [2, 3]'
             var anchor = predicate.GetAnchor();
             Console.WriteLine("anchor -> " + anchor); // will print 'anchor -> 1=1',  since the anchor is the last entry of the previous page.
             predicate.previousPage(); // we are setting up paging predicate to fetch previous page in the next call
             values = map.Values(predicate);
             Console.WriteLine("values = " + values) // will print 'values = [0, 1]'
             </code>
             </example>
        </member>
        <member name="M:Hazelcast.Core.PagingPredicate.#ctor(System.Int32,Hazelcast.Core.IPredicate,System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <summary>
            Creates a Paging predicate with provided page size and optional predicate and comparer.
            </summary>
            <param name="pageSize">page size of each result set</param>
            <param name="predicate">Optional predicate to filter of the results. if null, no filtering applied</param>
            <param name="comparer">Optional <see cref="T:System.Collections.IComparer"/> implementation used to sort the results. see warning at <see cref="P:Hazelcast.Core.PagingPredicate.Comparer"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException">if page size is negative</exception>
            <exception cref="T:System.ArgumentException">Nested PagingPredicate is not supported</exception>
        </member>
        <member name="P:Hazelcast.Core.PagingPredicate.Comparer">
            <summary>
            <c>IComparer&lt;KeyValuePair&lt;object, object&gt;&gt;</c>> implementation used to sort the result on client side.
            </summary>
            <remarks>
            <b>WARNING:</b> This comparer implementation should be hazelcast serializable and must have the same
            implementation on server side.
            </remarks>
        </member>
        <member name="P:Hazelcast.Core.PagingPredicate.Page">
            <summary>
            Current page index
            </summary>
        </member>
        <member name="P:Hazelcast.Core.PagingPredicate.PageSize">
            <summary>
            Page size of each iteration
            </summary>
        </member>
        <member name="P:Hazelcast.Core.PagingPredicate.IterationType">
            <summary>
            Iteration type this paging predicate: One of Key, Value or Entry
            </summary>
        </member>
        <member name="M:Hazelcast.Core.PagingPredicate.GetNearestAnchorEntry">
            <summary>
            After each query, an anchor entry is set for that page. <see cref="M:Hazelcast.Core.PagingPredicate.SetAnchor``2(System.Int32,``0,``1)"/>
            For the next query user may set an arbitrary <see cref="P:Hazelcast.Core.PagingPredicate.Page"/>.
            for example: user queried first 5 pages which means first 5 anchor is available
            if the next query is for the 10th page then the nearest anchor belongs to page 5
            but if the next query is for the 3nd page then the nearest anchor belongs to page 2
            </summary>
            <returns>nearest anchored entry for current page</returns>
        </member>
        <member name="M:Hazelcast.Core.PagingPredicate.Reset">
            <summary>
            resets for reuse
            </summary>
        </member>
        <member name="M:Hazelcast.Core.PagingPredicate.NextPage">
            <summary>
            sets the page value to next page
            </summary>
        </member>
        <member name="M:Hazelcast.Core.PagingPredicate.PreviousPage">
            <summary>
            sets the page value to previous page
            </summary>
        </member>
        <member name="T:Hazelcast.Core.Predicates">
            <summary>
                Helper mothod for creating builtin predicates
            </summary>
        </member>
        <member name="T:Hazelcast.Core.SqlPredicate">
            <summary>
                SQL Predicate
            </summary>
        </member>
        <member name="T:Hazelcast.Core.IProjection">
            <summary>
            Marker interface for server side projection implementation.
            Enables transforming object into other objects.
            Only 1:1 transformations allowed. Use an Aggregator to perform N:1 or N:M aggregations.
            <br/>
            Projection implementations must be hazelcast serializable and must have a counterpart/implementation on server side.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.SingleAttributeProjection">
            <summary>
            Projection that extracts the values of the given attribute and returns it.<br/>
            The attributePath does not support the [any] operator.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.TimeUnit">
            <summary>
            Represent Time units
            </summary>
        </member>
        <member name="T:Hazelcast.Core.IClient">
            <summary>
                IClient interface allows to get information about
                a connected clients socket address, type and uuid.
            </summary>
            <remarks>
                IClient interface allows to get information about
                a connected clients socket address, type and uuid.
            </remarks>
            <seealso cref="T:Hazelcast.Core.IClientService">IClientService</seealso>
            <seealso cref="T:Hazelcast.Core.IClientListener">IClientListener</seealso>
        </member>
        <member name="M:Hazelcast.Core.IClient.GetClientType">
            <summary>Returns type of this client</summary>
            <returns>type of this client</returns>
        </member>
        <member name="T:Hazelcast.Core.IClientListener">
            <summary>
                IClientListener allows to get notified when a
                <see cref="T:Hazelcast.Core.IClient">IClient</see>
                is connected to
                or disconnected from cluster.
            </summary>
            <seealso cref="T:Hazelcast.Core.IClient">IClient</seealso>
            <seealso cref="M:Hazelcast.Core.IClientService.AddClientListener(Hazelcast.Core.IClientListener)">IClientService.AddClientListener(IClientListener)</seealso>
        </member>
        <member name="M:Hazelcast.Core.IClientListener.ClientConnected(Hazelcast.Core.IClient)">
            <summary>Invoked when a new client is connected.</summary>
            <remarks>Invoked when a new client is connected.</remarks>
            <param name="client">IClient instance</param>
        </member>
        <member name="M:Hazelcast.Core.IClientListener.ClientDisconnected(Hazelcast.Core.IClient)">
            <summary>Invoked when a new client is disconnected.</summary>
            <remarks>Invoked when a new client is disconnected.</remarks>
            <param name="client">IClient instance</param>
        </member>
        <member name="T:Hazelcast.Core.IClientService">
            <summary>
                IClientService allows to query connected
                <see cref="T:Hazelcast.Core.IClient">IClient</see>
                s and
                attach/detach
                <see cref="T:Hazelcast.Core.IClientListener">IClientListener</see>
                s to listen connection events.
            </summary>
            <seealso cref="T:Hazelcast.Core.IClient">IClient</seealso>
            <seealso cref="T:Hazelcast.Core.IClientListener">IClientListener</seealso>
        </member>
        <member name="M:Hazelcast.Core.IClientService.AddClientListener(Hazelcast.Core.IClientListener)">
            <param name="clientListener">IClientListener</param>
            <returns>returns registration id.</returns>
        </member>
        <member name="M:Hazelcast.Core.IClientService.GetConnectedClients">
            <summary>Returns all connected clients to this member.</summary>
            <remarks>Returns all connected clients to this member.</remarks>
            <returns>all connected clients to this member.</returns>
        </member>
        <member name="M:Hazelcast.Core.IClientService.RemoveClientListener(System.String)">
            <param name="registrationId">Id of listener registration.</param>
            <returns>true if registration is removed, false otherwise</returns>
        </member>
        <member name="T:Hazelcast.Core.ClientType">
            <summary>Type of a client.</summary>
            <remarks>Type of a client.</remarks>
        </member>
        <member name="T:Hazelcast.Core.ICluster">
            <summary>Hazelcast cluster interface.</summary>
            <remarks>Hazelcast cluster interface.</remarks>
        </member>
        <member name="M:Hazelcast.Core.ICluster.AddMembershipListener(Hazelcast.Core.IMembershipListener)">
            <summary>Adds IMembershipListener to listen for membership updates.</summary>
            <remarks>
                Adds IMembershipListener to listen for membership updates.
                If the IMembershipListener implements the
                <see cref="T:Hazelcast.Core.IInitialMembershipListener">IInitialMembershipListener</see>
                interface, it will also receive
                the
                <see cref="T:Hazelcast.Core.InitialMembershipEvent">InitialMembershipEvent</see>
                .
            </remarks>
            <param name="listener">membership listener</param>
            <returns>returns registration id.</returns>
        </member>
        <member name="M:Hazelcast.Core.ICluster.GetClusterTime">
            <summary>Returns the cluster-wide time in milliseconds.</summary>
            <remarks>
                Returns the cluster-wide time in milliseconds.
                <p />
                ICluster tries to keep a cluster-wide time which is
                might be different than the member's own system time.
                ICluster-wide time is -almost- the same on all members
                of the cluster.
            </remarks>
            <returns>cluster-wide time</returns>
        </member>
        <member name="M:Hazelcast.Core.ICluster.GetLocalMember">
            <summary>Returns this Hazelcast instance member</summary>
            <returns>this Hazelcast instance member</returns>
        </member>
        <member name="M:Hazelcast.Core.ICluster.GetMembers">
            <summary>List of current members of the cluster.</summary>
            <remarks>
                List of current members of the cluster.
                Returning set instance is not modifiable.
                Every member in the cluster has the same member list in the same
                order. First member is the oldest member.
            </remarks>
            <returns>current members of the cluster</returns>
        </member>
        <member name="M:Hazelcast.Core.ICluster.RemoveMembershipListener(System.String)">
            <summary>Removes the specified membership listener.</summary>
            <remarks>Removes the specified membership listener.</remarks>
            <param name="registrationId">Id of listener registration.</param>
            <returns>true if registration is removed, false otherwise</returns>
        </member>
        <member name="T:Hazelcast.Core.IDistributedObject">
            <summary>Base interface for all distributed objects.</summary>
            <remarks>Base interface for all distributed objects.</remarks>
            <seealso cref="T:Hazelcast.Core.IMap`2">IMap&lt;K, V&gt;</seealso>
            <seealso cref="T:Hazelcast.Core.IQueue`1">IQueue&lt;E&gt;</seealso>
            <seealso cref="T:Hazelcast.Core.IMultiMap`2">IMultiMap&lt;K, V&gt;</seealso>
            <seealso cref="T:Hazelcast.Core.ITopic`1">ITopic&lt;E&gt;</seealso>
            <seealso cref="T:Hazelcast.Core.ILock">ILock</seealso>
            <seealso cref="T:Hazelcast.Core.IExecutorService">IExecutorService</seealso>
            <seealso cref="T:Hazelcast.Core.ITransactionalMap`2">ITransactionalMap&lt;K, V&gt;</seealso>
            <seealso cref="T:Hazelcast.Core.ITransactionalQueue`1">ITransactionalQueue&lt;E&gt;</seealso>
            <seealso cref="T:Hazelcast.Core.ITransactionalMultiMap`2">ITransactionalMultiMap&lt;K, V&gt;</seealso>
        </member>
        <member name="M:Hazelcast.Core.IDistributedObject.Destroy">
            <summary>Destroys this object cluster-wide.</summary>
            <remarks>
                Destroys this object cluster-wide.
                Clears and releases all resources for this object.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.IDistributedObject.GetName">
            <summary>Returns the unique name for this IDistributedObject.</summary>
            <remarks>Returns the unique name for this IDistributedObject. Returned value will never be null.</remarks>
            <returns>the unique name for this object.</returns>
        </member>
        <member name="M:Hazelcast.Core.IDistributedObject.GetPartitionKey">
            <summary>Returns the key of partition this IDistributedObject is assigned to.</summary>
            <remarks>
                Returns the key of partition this IDistributedObject is assigned to. The returned value only has meaning
                for a non partitioned data-structure like an IAtomicLong. For a partitioned data-structure like an IMap
                the returned value will not be null, but otherwise undefined.
            </remarks>
            <returns>the partition key.</returns>
        </member>
        <member name="M:Hazelcast.Core.IDistributedObject.GetServiceName">
            <summary>Returns the service name for this object.</summary>
            <remarks>Returns the service name for this object.</remarks>
        </member>
        <member name="T:Hazelcast.Core.DistributedObjectEvent">
            <summary>
                DistributedObjectEvent is fired when a
                <see cref="T:Hazelcast.Core.IDistributedObject">IDistributedObject</see>
                is created or destroyed cluster-wide.
            </summary>
            <seealso cref="T:Hazelcast.Core.IDistributedObject">IDistributedObject</seealso>
            <seealso cref="T:Hazelcast.Core.IDistributedObjectListener">IDistributedObjectListener</seealso>
        </member>
        <member name="M:Hazelcast.Core.DistributedObjectEvent.GetDistributedObject">
            <summary>Returns IDistributedObject instance</summary>
            <returns>IDistributedObject</returns>
        </member>
        <member name="M:Hazelcast.Core.DistributedObjectEvent.GetEventType">
            <summary>
                Returns type of this event; one of
                <see cref="F:Hazelcast.Core.DistributedObjectEvent.EventType.Created">EventType.Created</see>
                or
                <see cref="F:Hazelcast.Core.DistributedObjectEvent.EventType.Destroyed">EventType.Destroyed</see>
            </summary>
            <returns>eventType</returns>
        </member>
        <member name="T:Hazelcast.Core.IDistributedObjectListener">
            <summary>
                IDistributedObjectListener allows to get notified when a
                <see cref="T:Hazelcast.Core.IDistributedObject">IDistributedObject</see>
                is created or destroyed cluster-wide.
            </summary>
            <seealso cref="T:Hazelcast.Core.IDistributedObject">IDistributedObject</seealso>
            <seealso cref="M:Hazelcast.Core.IHazelcastInstance.AddDistributedObjectListener(Hazelcast.Core.IDistributedObjectListener)">IHazelcastInstance.AddDistributedObjectListener(IDistributedObjectListener)</seealso>
        </member>
        <member name="M:Hazelcast.Core.IDistributedObjectListener.DistributedObjectCreated(Hazelcast.Core.DistributedObjectEvent)">
            <summary>Invoked when a IDistributedObject is created.</summary>
            <remarks>Invoked when a IDistributedObject is created.</remarks>
            <param name="event">event</param>
        </member>
        <member name="M:Hazelcast.Core.IDistributedObjectListener.DistributedObjectDestroyed(Hazelcast.Core.DistributedObjectEvent)">
            <summary>Invoked when a IDistributedObject is destroyed.</summary>
            <remarks>Invoked when a IDistributedObject is destroyed.</remarks>
            <param name="event">event</param>
        </member>
        <member name="T:Hazelcast.Core.IEndpoint">
            <summary>Endpoint represents a peer in the cluster.</summary>
            <remarks>
                Endpoint represents a peer in the cluster.
                It can be either a member or a client.
            </remarks>
            <seealso cref="T:Hazelcast.Core.IMember">IMember</seealso>
            <seealso cref="T:Hazelcast.Core.IClient">IClient</seealso>
        </member>
        <member name="M:Hazelcast.Core.IEndpoint.GetSocketAddress">
            <summary>Returns socket address of this endpoint</summary>
            <returns>socket address of this endpoint</returns>
        </member>
        <member name="M:Hazelcast.Core.IEndpoint.GetUuid">
            <summary>Returns unique uuid for this endpoint</summary>
            <returns>unique uuid for this endpoint</returns>
        </member>
        <member name="T:Hazelcast.Core.EntryEvent`2">
            <summary>Map Entry event.</summary>
            <remarks>Map Entry event.</remarks>
            <typeparam name="TKey">type of key</typeparam>
            <typeparam name="TValue">type of value</typeparam>
            <seealso cref="T:Hazelcast.Core.IEntryListener`2" />
            <seealso cref="M:Hazelcast.Core.IMap`2.AddEntryListener(Hazelcast.Core.IEntryListener{`0,`1},System.Boolean)" />
        </member>
        <member name="M:Hazelcast.Core.EntryEvent`2.GetKey">
            <summary>Returns the key of the entry event</summary>
            <returns>the key</returns>
        </member>
        <member name="M:Hazelcast.Core.EntryEvent`2.GetOldValue">
            <summary>Returns the old value of the entry event</summary>
            <returns>the old value</returns>
        </member>
        <member name="M:Hazelcast.Core.EntryEvent`2.GetValue">
            <summary>Returns the value of the entry event</summary>
            <returns>the valueS</returns>
        </member>
        <member name="M:Hazelcast.Core.AbstractMapEvent.GetEventType">
            <summary>Return the event type</summary>
            <returns>event type</returns>
        </member>
        <member name="M:Hazelcast.Core.AbstractMapEvent.GetMember">
            <summary>Returns the member fired this event.</summary>
            <remarks>Returns the member fired this event.</remarks>
            <returns>the member fired this event.</returns>
        </member>
        <member name="M:Hazelcast.Core.AbstractMapEvent.GetName">
            <summary>Returns the name of the map for this event.</summary>
            <remarks>Returns the name of the map for this event.</remarks>
            <returns>name of the map.</returns>
        </member>
        <member name="M:Hazelcast.Core.EventObject.GetSource">
            <summary>
            The object on which the Event initially occurred.
            </summary>
            <returns>The object on which the Event initially occurred.</returns>
        </member>
        <member name="T:Hazelcast.Core.EntryEventType">
            <summary>Type of entry event.</summary>
            <remarks>Type of entry event.</remarks>
        </member>
        <member name="T:Hazelcast.Core.IEntryListener`2">
            <summary>
                Map Entry listener to get notified when a map entry
                is added, removed, updated or evicted.
            </summary>
            <remarks>
                Map Entry listener to get notified when a map entry
                is added, removed, updated or evicted.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.IEntryListener`2.EntryAdded(Hazelcast.Core.EntryEvent{`0,`1})">
            <summary>Invoked when an entry is added.</summary>
            <remarks>Invoked when an entry is added.</remarks>
            <param name="event">entry event</param>
        </member>
        <member name="M:Hazelcast.Core.IEntryListener`2.EntryEvicted(Hazelcast.Core.EntryEvent{`0,`1})">
            <summary>Invoked when an entry is evicted.</summary>
            <remarks>Invoked when an entry is evicted.</remarks>
            <param name="event">entry event</param>
        </member>
        <member name="M:Hazelcast.Core.IEntryListener`2.EntryRemoved(Hazelcast.Core.EntryEvent{`0,`1})">
            <summary>Invoked when an entry is removed.</summary>
            <remarks>Invoked when an entry is removed.</remarks>
            <param name="event">entry event</param>
        </member>
        <member name="M:Hazelcast.Core.IEntryListener`2.EntryUpdated(Hazelcast.Core.EntryEvent{`0,`1})">
            <summary>Invoked when an entry is updated.</summary>
            <remarks>Invoked when an entry is updated.</remarks>
            <param name="event">entry event</param>
        </member>
        <member name="M:Hazelcast.Core.IEntryListener`2.MapCleared(Hazelcast.Core.MapEvent)">
            <summary>Invoked when all entries are removed.</summary>
            <remarks>Invoked when all entries are removed.</remarks>
            <param name="event">entry event</param>
        </member>
        <member name="M:Hazelcast.Core.IEntryListener`2.MapEvicted(Hazelcast.Core.MapEvent)">
            <summary>Invoked when all entries are evicted.</summary>
            <remarks>Invoked when all entries are evicted.</remarks>
            <param name="event">entry event</param>
        </member>
        <member name="T:Hazelcast.Core.IEntryView`2">
            <summary>IEntryView represents a readonly view of a map entry.</summary>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetCost">
            <summary>Returns the cost (in bytes) of the entry.</summary>
            <remarks>
                Returns the cost (in bytes) of the entry.
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns -1 if statistics is not enabled.
                </p>
            </remarks>
            <returns>cost in bytes</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetCreationTime">
            <summary>Returns the creation time of the entry.</summary>
            <remarks>
                Returns the creation time of the entry.
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns -1 if statistics is not enabled.
                </p>
            </remarks>
            <returns>creation time</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetExpirationTime">
            <summary>Returns the expiration time of the entry.</summary>
            <remarks>Returns the expiration time of the entry.</remarks>
            <returns>expiration time</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetHits">
            <summary>Returns number of hits of the entry.</summary>
            <remarks>
                Returns number of hits of the entry.
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns -1 if statistics is not enabled.
                </p>
            </remarks>
            <returns>hits</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetKey">
            <summary>Returns the key of the entry.</summary>
            <remarks>Returns the key of the entry.</remarks>
            <returns>key</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetLastAccessTime">
            <summary>Returns the last access time to the entry.</summary>
            <remarks>
                Returns the last access time to the entry.
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns -1 if statistics is not enabled.
                </p>
            </remarks>
            <returns>last access time</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetLastStoredTime">
            <summary>Returns the last time value is flushed to mapstore.</summary>
            <remarks>
                Returns the last time value is flushed to mapstore.
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns -1 if statistics is not enabled.
                </p>
            </remarks>
            <returns>last store time</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetLastUpdateTime">
            <summary>Returns the last time value is updated.</summary>
            <remarks>
                Returns the last time value is updated.
                <p>
                    <b>Warning:</b>
                </p>
                <p>
                    This method returns -1 if statistics is not enabled.
                </p>
            </remarks>
            <returns>last update time</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetValue">
            <summary>Returns the value of the entry.</summary>
            <remarks>Returns the value of the entry.</remarks>
            <returns>value</returns>
        </member>
        <member name="M:Hazelcast.Core.IEntryView`2.GetVersion">
            <summary>Returns the version of the entry</summary>
            <returns>version</returns>
        </member>
        <member name="T:Hazelcast.Core.IExecutionCallback`1">
            <summary>
                IExecutionCallback allows to asynchronously get notified when the execution is completed,
                either successfully or with error.
            </summary>
            <remarks>
                IExecutionCallback allows to asynchronously get notified when the execution is completed,
                either successfully or with error.
            </remarks>
            <seealso cref="M:Hazelcast.Core.IExecutorService.Submit``1(Hazelcast.Util.Callable{``0},Hazelcast.Core.IExecutionCallback{``0})" />
            <seealso cref="M:Hazelcast.Core.IExecutorService.SubmitToMember``1(Hazelcast.Util.Callable{``0},Hazelcast.Core.IMember,Hazelcast.Core.IExecutionCallback{``0})" />
            <seealso cref="M:Hazelcast.Core.IExecutorService.SubmitToKeyOwner``1(Hazelcast.Util.Callable{``0},System.Object,Hazelcast.Core.IExecutionCallback{``0})" />
        </member>
        <member name="M:Hazelcast.Core.IExecutionCallback`1.OnFailure(System.Exception)">
            <summary>Called when an execution is completed with an error.</summary>
            <remarks>Called when an execution is completed with an error.</remarks>
            <param name="t">exception thrown</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutionCallback`1.OnResponse(`0)">
            <summary>Called when an execution is completed successfully.</summary>
            <remarks>Called when an execution is completed successfully.</remarks>
            <param name="response">result of execution</param>
        </member>
        <member name="T:Hazelcast.Core.HazelcastException">
            <summary>
            Base Hazelcast exception.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.DistributedObjectDestroyedException">
            <summary>
            A
            <see cref="T:Hazelcast.Core.HazelcastException"/>
            that indicates that a
            <see cref="T:Hazelcast.Core.IDistributedObject"/>
            access was attempted, but the object is destroyed.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.StaleSequenceException">
            <summary>
            An exception that is thrown when accessing an item in the <see cref="T:Hazelcast.Core.IRingbuffer`1">IRingbuffer</see> using a 
            sequence that is smaller than the current head sequence. This means that the and old item is read, 
            but it isn't available anymore in the ringbuffer.
            </summary>
        </member>
        <member name="T:Hazelcast.Core.IHazelcastInstance">
            <summary>Hazelcast instance.</summary>
            <remarks>
                Hazelcast instance. Each Hazelcast instance is a member (node) in a cluster.
                Multiple Hazelcast instances can be created.
                Each Hazelcast instance has its own socket, threads.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.AddDistributedObjectListener(Hazelcast.Core.IDistributedObjectListener)">
            <summary>
                Adds a Distributed Object listener which will be notified when a
                new
                <see cref="T:Hazelcast.Core.IDistributedObject">IDistributedObject</see>
                will be created or destroyed.
            </summary>
            <param name="distributedObjectListener">instance listener</param>
            <returns>returns registration id.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetAtomicLong(System.String)">
            <summary>Creates cluster-wide atomic long.</summary>
            <remarks>
                Creates cluster-wide atomic long. Hazelcast IAtomicLong is distributed
                implementation of <c>Interlocked</c>.
            </remarks>
            <param name="name">name of the IAtomicLong proxy</param>
            <returns>IAtomicLong proxy for the given name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetClientService">
            <summary>Returns the client service of this Hazelcast instance.</summary>
            <remarks>
                Returns the client service of this Hazelcast instance.
                IClient service allows you to get information about connected clients.
            </remarks>
            <returns>the IClientService.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetCluster">
            <summary>Returns the ICluster that this Hazelcast instance is part of.</summary>
            <remarks>
                Returns the ICluster that this Hazelcast instance is part of.
                ICluster interface allows you to add listener for membership
                events and learn more about the cluster that this Hazelcast
                instance is part of.
            </remarks>
            <returns>cluster that this Hazelcast instance is part of</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetCountDownLatch(System.String)">
            <summary>Creates cluster-wide CountDownLatch.</summary>
            <remarks>
                Creates cluster-wide CountDownLatch. Hazelcast ICountDownLatch is distributed
                implementation of <see cref="T:System.Threading.CountdownEvent"/>.
            </remarks>
            <param name="name">name of the ICountDownLatch proxy</param>
            <returns>ICountDownLatch proxy for the given name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetDistributedObject``1(System.String,System.String)">
            <param name="serviceName">name of the service</param>
            <param name="name">name of the object</param>
            <returns>IDistributedObject created by the service</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetDistributedObjects">
            <summary>
                Returns all
                <see cref="T:Hazelcast.Core.IDistributedObject">IDistributedObject</see>
                's such as; queue, map, set, list, topic, lock, multimap.
            </summary>
            <returns>the collection of instances created by Hazelcast.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetIdGenerator(System.String)">
            <summary>Creates cluster-wide unique IDs.</summary>
            <remarks>
                Creates cluster-wide unique IDs. Generated IDs are long type primitive values
                between <c>0</c> and <c>Int64.MaxValue</c> . Id generation occurs almost at the speed of
                <c>Interlocked.Increment(long)</c> . Generated IDs are unique during the life
                cycle of the cluster. If the entire cluster is restarted, IDs start from <c>0</c> again.
            </remarks>
            <param name="name">name of the IIdGenerator</param>
            <returns>IIdGenerator for the given name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetLifecycleService">
            <summary>Returns the lifecycle service for this instance.</summary>
            <remarks>
                Returns the lifecycle service for this instance. ILifecycleService allows you
                to shutdown this IHazelcastInstance and listen for
                the lifecycle events.
            </remarks>
            <returns>lifecycle service</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetList``1(System.String)">
            <summary>Returns the distributed list instance with the specified name.</summary>
            <remarks>
                Returns the distributed list instance with the specified name.
                Index based operations on the list are not supported.
            </remarks>
            <typeparam name="T">The type of elements in the list</typeparam>
            <param name="name">name of the distributed list</param>
            <returns>distributed list instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetLocalEndpoint">
            <summary>Returns the local Endpoint which this IHazelcastInstance is belongs to.</summary>
            <returns>local endpoint</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetLock(System.String)">
             <summary>Returns the distributed lock instance for the specified key object.</summary>
             <remarks>
                 Returns the distributed lock instance for the specified key object.
                 The specified object is considered to be the key for this lock.
                 So keys are considered equals cluster-wide as long as
                 they are serialized to the same byte array such as String, long,
                 Integer.
                 <p />
                 Locks are fail-safe. If a member holds a lock and some of the
                 members go down, cluster will keep your locks safe and available.
                 Moreover, when a member leaves the cluster, all the locks acquired
                 by this dead member will be removed so that these locks can be
                 available for live members immediately.
             </remarks>
             <param name="key">key of the lock instance</param>
             <returns>distributed lock instance for the specified key.</returns>
             <example>
             
             <code >
            Lock lock = hazelcastInstance.GetLock("PROCESS_LOCK");
            lock.lock();
            try
            {
             // process
            } 
            finally
            {
                lock.unlock();
            }
             </code>
             </example>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetMap``2(System.String)">
            <summary>
            Returns the distributed map instance with the specified name.
            </summary>
            <typeparam name="TKey">The type of the keys in the map</typeparam>
            <typeparam name="TValue">The type of the values in the map</typeparam>
            <param name="name">name of the distributed map</param>
            <returns>distributed map instance with the specified name</returns>
            <remarks>Returns the distributed map instance with the specified name.</remarks>
            <example>
            <code>
                var myMap = hazelcastInstance.GetMap&lt;string,int&gt;("theMap");
                myMap.Put("item1",10);
                int value=myMap.Get("item1");
                //value==10
            </code>
            </example>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetMultiMap``2(System.String)">
            <summary>Returns the distributed multimap instance with the specified name.</summary>
            <remarks>Returns the distributed multimap instance with the specified name.</remarks>
            <typeparam name="TKey">The type of the keys in the multimap</typeparam>
            <typeparam name="TValue">The type of the values in the multimap</typeparam>
            <param name="name">name of the distributed multimap</param>
            <returns>distributed multimap instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetName">
            <summary>Returns the name of this Hazelcast instance</summary>
            <returns>name of this Hazelcast instance</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetQueue``1(System.String)">
            <summary>
            Returns the distributed queue instance with the specified name.
            </summary>
            <typeparam name="T">The type of elements in the queue.</typeparam>
            <param name="name">name of the distributed queue</param>
            <returns>distributed queue instance with the specified name</returns>
            <remarks>Returns the distributed queue instance with the specified name.</remarks>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetRingbuffer``1(System.String)">
            <summary>Returns the distributed Ringbuffer instance with the specified name.</summary>
            <param name="name">name of the distributed Ringbuffer</param>
            <returns>distributed RingBuffer instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetSemaphore(System.String)">
            <summary>Creates cluster-wide semaphore.</summary>
            <remarks>
                Creates cluster-wide semaphore. Hazelcast ISemaphore is distributed
                implementation of <see cref="T:System.Threading.Semaphore"/>.
            </remarks>
            <param name="name">name of the ISemaphore proxy</param>
            <returns>ISemaphore proxy for the given name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetSet``1(System.String)">
            <summary>Returns the distributed set instance with the specified name.</summary>
            <remarks>Returns the distributed set instance with the specified name.</remarks>
            <typeparam name="T">The type of elements in the set</typeparam>
            <param name="name">name of the distributed set</param>
            <returns>distributed set instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetTopic``1(System.String)">
            <summary>Returns the distributed topic instance with the specified name.</summary>
            <remarks>Returns the distributed topic instance with the specified name.</remarks>
            <typeparam name="T">The type of elements in the Topic</typeparam>
            <param name="name">name of the distributed topic</param>
            <returns>distributed topic instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.GetUserContext">
            <summary>Returns a ConcurrentMap that can be used to add user-context to the IHazelcastInstance.</summary>
            <remarks>
                Returns a ConcurrentMap that can be used to add user-context to the IHazelcastInstance. This can be used
                to store dependencies that otherwise are hard to obtain. IHazelcastInstance can be
                obtained by implementing IHazelcastInstanceAware interface when submitting a Runnable/Callable to
                Hazelcast ExecutorService. By storing the dependencies in the user-context, they can be retrieved as soon
                as you have a reference to the IHazelcastInstance.
                <p />
                This structure is purely local and Hazelcast remains agnostic abouts its content.
            </remarks>
            <returns>the user context.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.NewTransactionContext">
            <summary>Creates a new ITransactionContext associated with the current thread using default options.</summary>
            <remarks>Creates a new ITransactionContext associated with the current thread using default options.</remarks>
            <returns>new ITransactionContext</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.NewTransactionContext(Hazelcast.Transaction.TransactionOptions)">
            <summary>Creates a new ITransactionContext associated with the current thread with given options.</summary>
            <remarks>Creates a new ITransactionContext associated with the current thread with given options.</remarks>
            <param name="options">options for this transaction</param>
            <returns>new ITransactionContext</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.RemoveDistributedObjectListener(System.String)">
            <summary>Removes the specified Distributed Object listener.</summary>
            <remarks>
                Removes the specified Distributed Object listener. Returns silently
                if specified instance listener doesn't exist.
            </remarks>
            <param name="registrationId">Id of listener registration.</param>
            <returns>true if registration is removed, false otherwise</returns>
        </member>
        <member name="M:Hazelcast.Core.IHazelcastInstance.Shutdown">
            <summary>Shuts down this IHazelcastInstance.</summary>
            <remarks>
                Shuts down this IHazelcastInstance. For more information see
                <see cref="T:Hazelcast.Core.ILifecycleService"/>.
            </remarks>
        </member>
        <member name="T:Hazelcast.Core.IHazelcastInstanceAware">
            <summary>Used to get IHazelcastInstance reference when submitting a Runnable/Callable using Hazelcast ExecutorService.</summary>
            <remarks>
                Used to get IHazelcastInstance reference when submitting a Runnable/Callable using Hazelcast ExecutorService.
                Before executing the Runnable/Callable Hazelcast will invoke
                <see cref="M:Hazelcast.Core.IHazelcastInstanceAware.SetHazelcastInstance(Hazelcast.Core.IHazelcastInstance)">SetHazelcastInstance(IHazelcastInstance)</see>
                method with
                the reference to IHazelcastInstance that is executing. This way the implementer will have a chance to get the
                reference to IHazelcastInstance.
            </remarks>
        </member>
        <member name="T:Hazelcast.Core.HazelcastInstanceNotActiveException">
            <summary>Thrown when IHazelcastInstance is not active during an invocation.</summary>
            <remarks>Thrown when IHazelcastInstance is not active during an invocation.</remarks>
        </member>
        <member name="T:Hazelcast.Core.IHCollection`1">
            <summary>Concurrent, distributed, partitioned, listenable collection.</summary>
            <remarks>Concurrent, distributed, partitioned, listenable collection.</remarks>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.Add(`0)">
            <summary>
            Adds the specified item.
            </summary>
            <param name="item">The item.</param>
            <returns><c>true</c> if added, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.AddAll``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Adds all.
            </summary>
            <typeparam name="TE">type of elements</typeparam>
            <param name="c">element collection</param>
            <returns><c>true</c> if this collection changed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.AddItemListener(Hazelcast.Core.IItemListener{`0},System.Boolean)">
            <summary>Adds an item listener for this collection.</summary>
            <remarks>
            Adds an item listener for this collection. Listener will get notified
            for all collection add/remove events.
            </remarks>
            <param name="listener">item listener</param>
            <param name="includeValue">
            <TE>true</TE> updated item should be passed
            to the item listener, <TE>false</TE> otherwise.
            </param>
            <returns>returns registration id.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.ContainsAll``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Determines whether this collection contains all of the elements in the specified collection.
            </summary>
            <typeparam name="TE">type of elements</typeparam>
            <param name="c">The collection</param>
            <returns><c>true</c> if this collection contains all of the elements in the specified collection; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.IsEmpty">
            <summary>
            Determines whether this instance is empty.
            </summary>
            <returns><c>true</c> if this instance is empty; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.RemoveAll``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Removes all of the elements in the specified collection from this collection.
            </summary>
            <typeparam name="TE">type of elements</typeparam>
            <param name="c">element collection to be removed</param>
            <returns><c>true</c> if all removed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.RemoveItemListener(System.String)">
            <summary>Removes the specified item listener.</summary>
            <remarks>
            Removes the specified item listener.
            Returns silently if the specified listener is not added before.
            </remarks>
            <param name="registrationId">Id of listener registration.</param>
            <returns>true if registration is removed, false otherwise</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.RetainAll``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Retains only the elements in this collection that are contained in the specified collection (optional operation).
            </summary>
            <remarks>
            Retains only the elements in this collection that are contained in the specified collection (optional operation).
            In other words, removes from this collection all of its elements that are not contained in the specified collection
            </remarks>
            <typeparam name="TE">type of elements</typeparam>
            <param name="c">The c.</param>
            <returns><c>true</c> if this collection changed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.Size">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
            <returns>
            The number of elements contained in the collection.
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.ToArray">
            <summary>
            Returns an array containing all of the elements in this collection.
            </summary>
            <returns>an array containing all of the elements in this collection.</returns>
        </member>
        <member name="M:Hazelcast.Core.IHCollection`1.ToArray``1(``0[])">
            <summary>
            Returns an array containing all of the elements in this collection 
            the runtime type of the returned array is that of the specified array
            </summary>
            <typeparam name="TE">return array type</typeparam>
            <param name="a">the array into which the elements of this collection are to be 
            stored, if it is big enough; otherwise, a new array of the same 
            runtime type is allocated for this purpose</param>
            <returns>an array containing all of the elements in this collection</returns>
        </member>
        <member name="T:Hazelcast.Core.ICountDownLatch">
            <summary>
                ICountDownLatch is a backed-up distributed alternative to the
                .
                <p />
                ICountDownLatch is a cluster-wide synchronization aid
                that allows one or more threads to wait until a set of operations being
                performed in other threads completes.
                <p />
                There are a few differences compared to the
                <see cref="T:Hazelcast.Core.ICountDownLatch">ICountDownLatch</see>
                :
                <ol>
                    <li>
                        the ICountDownLatch count can be re-set using
                        <see cref="M:Hazelcast.Core.ICountDownLatch.TrySetCount(System.Int32)">TrySetCount(int)</see>
                        after a countdown
                        has finished but not during an active count. This allows the same latch instance to be reused.
                    </li>
                    <li>
                        there is no await() method to do an unbound wait since this is undesirable in a distributed
                        application: it can happen that for example a cluster is split or that the master and
                        replica's all die. So in most cases it is best to configure an explicit timeout so have the ability
                        to deal with these situations.
                    </li>
                </ol>
            </summary>
        </member>
        <member name="M:Hazelcast.Core.ICountDownLatch.Await(System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
                Causes the current thread to wait until the latch has counted down to
                zero, an exception is thrown, or the specified waiting time elapses.
            </summary>
            <remarks>
                Causes the current thread to wait until the latch has counted down to
                zero, an exception is thrown, or the specified waiting time elapses.
                <p />
                <p>
                    If the current count is zero then this method returns immediately
                    with the value
                    <code>true</code>
                    .
                </p>
                <p>
                    If the current count is greater than zero then the current
                    thread becomes disabled for thread scheduling purposes and lies
                    dormant until one of five things happen:
                    <ul>
                        <li>
                            The count reaches zero due to invocations of the
                            <see cref="M:Hazelcast.Core.ICountDownLatch.CountDown">CountDown()</see>
                            method;
                        </li>
                        <li>
                            This ICountDownLatch instance is destroyed;
                        </li>
                        <li>
                            The countdown owner becomes disconnected;
                        </li>
                        <li>
                            Some other thread
                            the current thread; or
                        </li>
                        <li>
                            The specified waiting time elapses.
                        </li>
                    </ul>
                </p>
                <p>
                    If the count reaches zero then the method returns with the
                    value
                    <code>true</code>
                    .
                </p>
                <p>
                    If the current thread:
                    <ul>
                        <li>
                            has its interrupted status set on entry to this method; or
                        </li>
                        <li>
                            is
                            while waiting,
                        </li>
                    </ul>
                    then
                    <see cref="T:System.Exception">System.Exception</see>
                    is thrown and the current thread's
                    interrupted status is cleared.
                    <p>
                        If the specified waiting time elapses then the value
                        <code>false</code>
                        is returned.  If the time is less than or equal to zero, the method
                        will not wait at all.
                    </p>
                </p>
            </remarks>
            <param name="timeout">the maximum time to wait</param>
            <param name="unit">
                the time unit of the
                <code>timeout</code>
                argument
            </param>
            <returns>
                <code>true</code>
                if the count reached zero and
                <code>false</code>
                if the waiting time elapsed before the count reached zero
            </returns>
            <exception cref="T:System.Exception">if the current thread is interrupted</exception>
            <exception cref="T:System.InvalidOperationException">if hazelcast instance is shutdown while waiting</exception>
        </member>
        <member name="M:Hazelcast.Core.ICountDownLatch.CountDown">
            <summary>
                Decrements the count of the latch, releasing all waiting threads if
                the count reaches zero.
            </summary>
            <remarks>
                Decrements the count of the latch, releasing all waiting threads if
                the count reaches zero.
                <p />
                If the current count is greater than zero then it is decremented.
                If the new count is zero:
                <ul>
                    <li>
                        All waiting threads are re-enabled for thread scheduling purposes; and
                    </li>
                    <li>
                        Countdown owner is set to
                        <code>null</code>
                        .
                    </li>
                </ul>
                <p />
                If the current count equals zero then nothing happens.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.ICountDownLatch.GetCount">
            <summary>Returns the current count.</summary>
            <remarks>Returns the current count.</remarks>
            <returns>current count</returns>
        </member>
        <member name="M:Hazelcast.Core.ICountDownLatch.TrySetCount(System.Int32)">
            <summary>Sets the count to the given value if the current count is zero.</summary>
            <remarks>
                Sets the count to the given value if the current count is zero.
                <p />If count is not zero then this method does nothing and returns
                <code>false</code>
                .
            </remarks>
            <param name="count">
                the number of times
                <see cref="M:Hazelcast.Core.ICountDownLatch.CountDown">CountDown()</see>
                must be invoked
                before threads can pass through
                <see cref="M:Hazelcast.Core.ICountDownLatch.Await(System.Int64,Hazelcast.Core.TimeUnit)">Await(long, TimeUnit)</see>
            </param>
            <returns>
                <code>true</code>
                if the new count was set or
                <code>false</code>
                if the current
                count is not zero
            </returns>
            <exception cref="T:System.ArgumentException">
                if
                <code>count</code>
                is negative
            </exception>
        </member>
        <member name="T:Hazelcast.Core.IExecutorService">
            <summary>
                Distributed implementation of ExecutorService.
                IExecutorService provides additional methods like executing tasks
                on a specific member, on a member who is owner of a specific key,
                executing a tasks on multiple members and listening execution result using a callback.
            </summary>
            <seealso cref="T:Hazelcast.Core.IExecutionCallback`1" />
            <seealso cref="T:Hazelcast.Core.IMultiExecutionCallback" />
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.ExecuteOnAllMembers(Hazelcast.Util.Runnable)">
            <summary>Executes task on all of known cluster members</summary>
            <param name="command">task</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.ExecuteOnKeyOwner(Hazelcast.Util.Runnable,System.Object)">
            <summary>Executes task on owner of the specified key</summary>
            <param name="command">task</param>
            <param name="key">key</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.ExecuteOnMember(Hazelcast.Util.Runnable,Hazelcast.Core.IMember)">
            <summary>Executes task on the specified member</summary>
            <param name="command">task</param>
            <param name="member">member</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.ExecuteOnMembers(Hazelcast.Util.Runnable,System.Collections.Generic.ICollection{Hazelcast.Core.IMember})">
            <summary>Executes task on each of the specified members</summary>
            <param name="command">task</param>
            <param name="members">members</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.Submit``1(Hazelcast.Util.Runnable,Hazelcast.Core.IExecutionCallback{``0})">
            <summary>Submits task to a random member.</summary>
            <remarks>
                Submits task to a random member. Caller will be notified for the result of the task by
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnResponse(`0)" />
                or
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnFailure(System.Exception)" />
                .
            </remarks>
            <param name="task">task</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.Submit``1(Hazelcast.Util.Callable{``0},Hazelcast.Core.IExecutionCallback{``0})">
            <summary>Submits task to a random member.</summary>
            <remarks>
                Submits task to a random member. Caller will be notified for the result of the task by
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnResponse(`0)" />
                or
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnFailure(System.Exception)" />
                .
            </remarks>
            <param name="task">task</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToAllMembers``1(Hazelcast.Util.Callable{``0})">
            <summary>
                Submits task to all cluster members and returns
                map of IMember-Future pairs representing pending completion of the task on each member
            </summary>
            <param name="task">task</param>
            <returns>map of IMember-Future pairs representing pending completion of the task on each member</returns>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToAllMembers(Hazelcast.Util.Runnable,Hazelcast.Core.IMultiExecutionCallback)">
            <summary>Submits task to the all cluster members.</summary>
            <remarks>
                Submits task to the all cluster members. Caller will be notified for the result of the each task by
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnResponse(Hazelcast.Core.IMember,System.Object)"  />
                , and when all tasks are completed,
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnComplete(System.Collections.Generic.IDictionary{Hazelcast.Core.IMember,System.Object})" />
                will be called.
            </remarks>
            <param name="task">task</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToAllMembers``1(Hazelcast.Util.Callable{``0},Hazelcast.Core.IMultiExecutionCallback)">
            <summary>Submits task to the all cluster members.</summary>
            <remarks>
                Submits task to the all cluster members. Caller will be notified for the result of the each task by
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnResponse(Hazelcast.Core.IMember,System.Object)" />
                , and when all tasks are completed,
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnComplete(System.Collections.Generic.IDictionary{Hazelcast.Core.IMember,System.Object})" />
                will be called.
            </remarks>
            <param name="task">task</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToKeyOwner``1(Hazelcast.Util.Callable{``0},System.Object)">
            <summary>
                Submits task to owner of the specified key and returns a Future
                representing that task.
            </summary>
            <remarks>
                Submits task to owner of the specified key and returns a Future
                representing that task.
            </remarks>
            <param name="task">task</param>
            <param name="key">key</param>
            <returns>a Future representing pending completion of the task</returns>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToKeyOwner``1(Hazelcast.Util.Runnable,System.Object,Hazelcast.Core.IExecutionCallback{``0})">
            <summary>Submits task to owner of the specified key.</summary>
            <remarks>
                Submits task to owner of the specified key. Caller will be notified for the result of the task by
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnResponse(`0)" />
                or
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnFailure(System.Exception)" />
                .
            </remarks>
            <param name="task">task</param>
            <param name="key">the specified key</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToKeyOwner``1(Hazelcast.Util.Callable{``0},System.Object,Hazelcast.Core.IExecutionCallback{``0})">
            <summary>Submits task to owner of the specified key.</summary>
            <remarks>
                Submits task to owner of the specified key. Caller will be notified for the result of the task by
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnResponse(`0)"/>
                or
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnFailure(System.Exception)" />
                .
            </remarks>
            <param name="task">task</param>
            <param name="key">key to execute on</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToMember``1(Hazelcast.Util.Callable{``0},Hazelcast.Core.IMember)">
            <summary>
                Submits task to specified member and returns a Future
                representing that task.
            </summary>
            <remarks>
                Submits task to specified member and returns a Future
                representing that task.
            </remarks>
            <param name="task">task</param>
            <param name="member">member</param>
            <returns>a Future representing pending completion of the task</returns>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToMember``1(Hazelcast.Util.Runnable,Hazelcast.Core.IMember,Hazelcast.Core.IExecutionCallback{``0})">
            <summary>Submits task to the specified member.</summary>
            <remarks>
                Submits task to the specified member. Caller will be notified for the result of the task by
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnResponse(`0)" />
                or
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnFailure(System.Exception)" />
                .
            </remarks>
            <param name="task">task</param>
            <param name="member">the specified member</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToMember``1(Hazelcast.Util.Callable{``0},Hazelcast.Core.IMember,Hazelcast.Core.IExecutionCallback{``0})">
            <summary>Submits task to the specified member.</summary>
            <remarks>
                Submits task to the specified member. Caller will be notified for the result of the task by
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnResponse(`0)" />
                or
                <see cref="M:Hazelcast.Core.IExecutionCallback`1.OnFailure(System.Exception)" />
                .
            </remarks>
            <param name="task">task</param>
            <param name="member">Member to execute tasks on</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToMembers``1(Hazelcast.Util.Callable{``0},System.Collections.Generic.ICollection{Hazelcast.Core.IMember})">
            <summary>
                Submits task to given members and returns
                map of IMember-Future pairs representing pending completion of the task on each member
            </summary>
            <param name="task">task</param>
            <param name="members">members</param>
            <returns>map of IMember-Future pairs representing pending completion of the task on each member</returns>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToMembers(Hazelcast.Util.Runnable,System.Collections.Generic.ICollection{Hazelcast.Core.IMember},Hazelcast.Core.IMultiExecutionCallback)">
            <summary>Submits task to the specified members.</summary>
            <remarks>
                Submits task to the specified members. Caller will be notified for the result of the each task by
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnResponse(Hazelcast.Core.IMember,System.Object)"/>
                , and when all tasks are completed,
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnComplete(System.Collections.Generic.IDictionary{Hazelcast.Core.IMember,System.Object})" />
                will be called.
            </remarks>
            <param name="task">task</param>
            <param name="members">the specified members</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:Hazelcast.Core.IExecutorService.SubmitToMembers``1(Hazelcast.Util.Callable{``0},System.Collections.Generic.ICollection{Hazelcast.Core.IMember},Hazelcast.Core.IMultiExecutionCallback)">
            <summary>Submits task to the specified members.</summary>
            <remarks>
                Submits task to the specified members. Caller will be notified for the result of the each task by
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnResponse(Hazelcast.Core.IMember,System.Object)">IMultiExecutionCallback.OnResponse(IMember, object)</see>
                , and when all tasks are completed,
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnComplete(System.Collections.Generic.IDictionary{Hazelcast.Core.IMember,System.Object})">
                    IMultiExecutionCallback.OnComplete(System.Collections.Generic.IDictionary
                    &lt;IMember, object&gt;)
                </see>
                will be called.
            </remarks>
            <param name="task">task</param>
            <param name="members">List of members to execute on</param>
            <param name="callback">callback</param>
        </member>
        <member name="T:Hazelcast.Core.ILock">
            <summary>
                Distributed implementation of Lock
            </summary>
        </member>
        <member name="M:Hazelcast.Core.ILock.ForceUnlock">
            <summary>Releases the lock regardless of the lock owner.</summary>
            <remarks>
                Releases the lock regardless of the lock owner.
                It always successfully unlocks, never blocks  and returns immediately.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.ILock.GetLockCount">
            <summary>Returns re-entrant lock hold count, regardless of lock ownership.</summary>
            <remarks>Returns re-entrant lock hold count, regardless of lock ownership.</remarks>
            <returns>lock hold count.</returns>
        </member>
        <member name="M:Hazelcast.Core.ILock.GetRemainingLeaseTime">
            <summary>Returns remaining lease time in milliseconds.</summary>
            <remarks>
                Returns remaining lease time in milliseconds.
                If the lock is not locked then -1 will be returned.
            </remarks>
            <returns>remaining lease time in milliseconds.</returns>
        </member>
        <member name="M:Hazelcast.Core.ILock.IsLocked">
            <summary>Returns whether this lock is locked or not.</summary>
            <remarks>Returns whether this lock is locked or not.</remarks>
            <returns>
                <code>true</code>
                if this lock is locked,
                <code>false</code>
                otherwise.
            </returns>
        </member>
        <member name="M:Hazelcast.Core.ILock.IsLockedByCurrentThread">
            <summary>Returns whether this lock is locked by current thread or not.</summary>
            <remarks>Returns whether this lock is locked by current thread or not.</remarks>
            <returns>
                <code>true</code>
                if this lock is locked by current thread,
                <code>false</code>
                otherwise.
            </returns>
        </member>
        <member name="M:Hazelcast.Core.ILock.Lock">
             <summary>
            Acquires the lock.
             </summary>
             <remarks>
                 Acquires the lock.
                 <p>
                    If the lock is not available then
                    the current thread becomes disabled for thread scheduling
                    purposes and lies dormant until the lock has been acquired.
                 </p>
             </remarks>
        </member>
        <member name="M:Hazelcast.Core.ILock.Lock(System.Int64,System.Nullable{Hazelcast.Core.TimeUnit})">
            <summary>Acquires the lock for the specified lease time.</summary>
            <remarks>
                Acquires the lock for the specified lease time.
                <p>After lease time, lock will be released.</p>
                <p>
                   If the lock is not available then
                   the current thread becomes disabled for thread scheduling
                   purposes and lies dormant until the lock has been acquired.
                </p>
            </remarks>
            <param name="leaseTime">time to wait before releasing the lock.</param>
            <param name="timeUnit">unit of time to specify lease time.</param>
        </member>
        <member name="M:Hazelcast.Core.ILock.TryLock">
            <summary>
            Tries to acquires the lock and returns immediately.
            </summary>
            <returns><c>true</c> if acquires the lock, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Core.ILock.TryLock(System.Int64,System.Nullable{Hazelcast.Core.TimeUnit})">
            <summary>Tries to acquires the lock for the specified lease time.</summary>
            <remarks>
                Tries to acquires the lock for the specified lease time.
                <p>After lease time, lock will be released.</p>
            </remarks>
            <param name="time">time to wait before releasing the lock.</param>
            <param name="unit">unit of time to specify lease time.</param>
        </member>
        <member name="M:Hazelcast.Core.ILock.Unlock">
            <summary>Releases the lock.</summary>
            <remarks>Releases the lock.</remarks>
        </member>
        <member name="T:Hazelcast.Core.InitialMembershipEvent">
            <summary>
                A event that is send when a
                <see cref="T:Hazelcast.Core.IInitialMembershipListener">IInitialMembershipListener</see>
                registers itself on a
                <see cref="T:Hazelcast.Core.ICluster">ICluster</see>
                . For more
                information see the
                <see cref="T:Hazelcast.Core.IInitialMembershipListener">IInitialMembershipListener</see>
                .
            </summary>
            <seealso cref="T:Hazelcast.Core.IInitialMembershipListener">IInitialMembershipListener</seealso>
            <seealso cref="T:Hazelcast.Core.IMembershipListener">IMembershipListener</seealso>
            <seealso cref="T:Hazelcast.Core.MembershipEvent">MembershipEvent</seealso>
        </member>
        <member name="M:Hazelcast.Core.InitialMembershipEvent.GetCluster">
            <summary>Returns the cluster of the event.</summary>
            <remarks>Returns the cluster of the event.</remarks>
            <returns>the cluster of the event.</returns>
        </member>
        <member name="M:Hazelcast.Core.InitialMembershipEvent.GetMembers">
            <summary>
                Returns an immutable set of ordered members at the moment this
                <see cref="T:Hazelcast.Core.IInitialMembershipListener">IInitialMembershipListener</see>
                is
                registered. See
                <see cref="M:Hazelcast.Core.ICluster.GetMembers">ICluster.GetMembers()</see>
                for more information.
            </summary>
            <returns>a set of members.</returns>
        </member>
        <member name="T:Hazelcast.Core.IInitialMembershipListener">
            <summary>
                The InitializingMembershipListener is a
                <see cref="T:Hazelcast.Core.IMembershipListener">IMembershipListener</see>
                that will first receives a
                <see cref="T:Hazelcast.Core.InitialMembershipEvent">InitialMembershipEvent</see>
                when it is registered so it immediately knows which members are available. After
                that event has been received, it will receive the normal MembershipEvents.
                When the InitializingMembershipListener already is registered on a
                <see cref="T:Hazelcast.Core.ICluster">ICluster</see>
                and is registered again on the same
                ICluster instance, it will not receive an additional MembershipInitializeEvent. So this is a once only event.
            </summary>
            <seealso cref="M:Hazelcast.Core.ICluster.AddMembershipListener(Hazelcast.Core.IMembershipListener)">ICluster.AddMembershipListener(IMembershipListener)</seealso>
            <seealso cref="M:Hazelcast.Core.MembershipEvent.GetMembers">MembershipEvent.GetMembers()</seealso>
        </member>
        <member name="M:Hazelcast.Core.IInitialMembershipListener.Init(Hazelcast.Core.InitialMembershipEvent)">
            <summary>Is called when this listener is registered.</summary>
            <remarks>Is called when this listener is registered.</remarks>
            <param name="membershipEvent">the MembershipInitializeEvent</param>
        </member>
        <member name="T:Hazelcast.Core.ISemaphore">
            <summary>
                ISemaphore is a backed-up distributed alternative to the
                <see cref="T:System.Threading.Semaphore">System.Threading.Semaphore</see>
                .
            </summary>
            <remarks>
                <p />
                ISemaphore is a cluster-wide counting semaphore.  Conceptually,
                it maintains a set of permits.  Each
                <see cref="M:Hazelcast.Core.ISemaphore.Acquire">Acquire()</see>
                blocks if necessary until
                a permit is available, and then takes it.  Each
                <see cref="M:Hazelcast.Core.ISemaphore.Release">Release()</see>
                adds a permit,
                potentially releasing a blocking acquirer. However, no actual permit objects are
                used; the semaphore just keeps a count of the number available and acts accordingly.
                <p/>The Hazelcast distributed semaphore implementation guarantees that
                threads invoking any of the
                <see cref="M:Hazelcast.Core.ISemaphore.Acquire">acquire</see>
                methods are selected
                to obtain permits in the order in which their invocation of those methods
                was processed(first-in-first-out; FIFO).  Note that FIFO ordering necessarily
                applies to specific internal points of execution within the cluster.  So,
                it is possible for one member to invoke
                <c>acquire</c>
                before another, but reach
                the ordering point after the other, and similarly upon return from the method.
                <p />This class also provides convenience methods to
                <see cref="M:Hazelcast.Core.ISemaphore.Acquire(System.Int32)">acquire</see>
                and
                <see cref="M:Hazelcast.Core.ISemaphore.Release(System.Int32)">release</see>
                multiple
                permits at a time.  Beware of the increased risk of indefinite
                postponement when using the multiple acquire.  If a single permit is
                released to a semaphore that is currently blocking, a thread waiting
                for one permit will acquire it before a thread waiting for multiple
                permits regardless of the call order.
                <p />
                <ul>
                    <li>Correct usage of a semaphore is established by programming convention in the application.</li>
                </ul>
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.Acquire">
            <summary>
                    Acquires a permit, if one is available and returns immediately,
                    reducing the number of available permits by one.
            </summary>
            <remarks>
                    Acquires a permit, if one is available and returns immediately,
                    reducing the number of available permits by one.
                    <p />
                        If no permit is available then the current thread becomes
                        disabled for thread scheduling purposes and lies dormant until
                        one of two things happens:
                        <ul>
                            <li>
                                Some other thread invokes one of the
                                <see cref="M:Hazelcast.Core.ISemaphore.Release">Release()</see>
                                methods for this
                                semaphore and the current thread is next to be assigned a permit;
                            </li>
                            <li>
                                This ISemaphore instance is destroyed; or
                            </li>
                        </ul>
            </remarks>
            <exception cref="T:System.InvalidOperationException">if hazelcast instance is shutdown while waiting</exception>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.Acquire(System.Int32)">
            <summary>
                    Acquires the given number of permits, if they are available,
                    and returns immediately, reducing the number of available permits
                    by the given amount.
            </summary>
            <remarks>
                    Acquires the given number of permits, if they are available,
                    and returns immediately, reducing the number of available permits
                    by the given amount.
                    <p />
                        If insufficient permits are available then the current thread becomes
                        disabled for thread scheduling purposes and lies dormant until
                        one of two things happens:
                        <ul>
                            <li>
                                Some other thread invokes one of the
                                <see cref="M:Hazelcast.Core.ISemaphore.Release">release</see>
                                methods for this semaphore, the current thread is next to be assigned
                                permits and the number of available permits satisfies this request;
                            </li>
                            <li>
                                This ISemaphore instance is destroyed; 
                            </li>
                       </ul>
            </remarks>
            <param name="permits">the number of permits to acquire</param>
            <exception cref="T:System.ArgumentException">
                if
                <c>permits</c>
                is negative
            </exception>
            <exception cref="T:System.InvalidOperationException">if hazelcast instance is shutdown while waiting</exception>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.AvailablePermits">
            <summary>Returns the current number of permits currently available in this semaphore.</summary>
            <remarks>
                Returns the current number of permits currently available in this semaphore.
                <p />
                <ul>
                    <li>This method is typically used for debugging and testing purposes.</li>
                </ul>
            </remarks>
            <returns>the number of permits available in this semaphore</returns>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.DrainPermits">
            <summary>Acquires and returns all permits that are immediately available.</summary>
            <remarks>Acquires and returns all permits that are immediately available.</remarks>
            <returns>the number of permits drained</returns>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.Init(System.Int32)">
            <summary>Try to initialize this ISemaphore instance with given permit count</summary>
            <returns>true if initialization success</returns>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.ReducePermits(System.Int32)">
            <summary>
                Shrinks the number of available permits by the indicated
                reduction.
            </summary>
            <remarks>
                Shrinks the number of available permits by the indicated
                reduction. This method differs from
                <c>acquire</c>
                in that it does not
                block waiting for permits to become available.
            </remarks>
            <param name="reduction">the number of permits to remove</param>
            <exception cref="T:System.ArgumentException">
                if
                <c>reduction</c>
                is negative
            </exception>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.Release">
            <summary>
                Releases a permit, increasing the number of available permits by
                one.
            </summary>
            <remarks>
                Releases a permit, increasing the number of available permits by
                one.  If any threads in the cluster are trying to acquire a permit,
                then one is selected and given the permit that was just released.
                <p />
                There is no requirement that a thread that releases a permit must
                have acquired that permit by calling one of the
                <see cref="M:Hazelcast.Core.ISemaphore.Acquire">acquire</see>
                methods.
                Correct usage of a semaphore is established by programming convention
                in the application.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.Release(System.Int32)">
            <summary>
                Releases the given number of permits, increasing the number of
                available permits by that amount.
            </summary>
            <remarks>
                Releases the given number of permits, increasing the number of
                available permits by that amount.
                <p />
                There is no requirement that a thread that releases a permit must
                have acquired that permit by calling one of the
                <see cref="M:Hazelcast.Core.ISemaphore.Acquire">acquire</see>
                methods.
                Correct usage of a semaphore is established by programming convention
                in the application.
            </remarks>
            <param name="permits">the number of permits to release</param>
            <exception cref="T:System.ArgumentException">
                if
                <c>permits</c>
                is negative
            </exception>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.TryAcquire">
            <summary>
                Acquires a permit, if one is available and returns immediately,
                with the value  <c>true</c>, reducing the number of available permits by one.
            </summary>
            <remarks>
                Acquires a permit, if one is available and returns immediately,
                with the value  <c>true</c>, reducing the number of available permits by one.
                <p />
                If no permit is available then this method will return
                immediately with the value <c>false</c>.
            </remarks>
            <returns>
                <c>true</c>
                if a permit was acquired and
                <c>false</c>
                otherwise
            </returns>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.TryAcquire(System.Int32)">
            <summary>
                Acquires the given number of permits, if they are available, and
                returns immediately, with the value <c>true</c>,
                reducing the number of available permits by the given amount.
            </summary>
            <remarks>
                Acquires the given number of permits, if they are available, and
                returns immediately, with the value <c>true</c>,
                reducing the number of available permits by the given amount.
            <p/>
                   If insufficient permits are available then this method will return
                   immediately with the value
                   <c>false</c>
                   and the number of available
                   permits is unchanged.
            </remarks>
            <param name="permits">the number of permits to acquire</param>
            <returns>
                <c>true</c>
                if the permits were acquired and
                <c>false</c>
                otherwise
            </returns>
            <exception cref="T:System.ArgumentException">
                if
                <c>permits</c>
                is negative
            </exception>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.TryAcquire(System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
                Acquires a permit from this semaphore, if one becomes available
                within the given waiting time and the current thread has not
                been <see cref="M:System.Threading.Thread.Interrupt">interrupted</see>.
            </summary>
            <remarks>
                Acquires a permit from this semaphore, if one becomes available
                within the given waiting time and the current thread has not
                been <see cref="M:System.Threading.Thread.Interrupt">interrupted</see>.
                <p />
                Acquires a permit, if one is available and returns immediately,
                with the value <c>true</c>, reducing the number of available permits by one.
                <p />
                If no permit is available then the current thread becomes
                disabled for thread scheduling purposes and lies dormant until
                one of three things happens:
                <ul>
                    <li>
                        Some other thread invokes the
                        <see cref="M:Hazelcast.Core.ISemaphore.Release">Release()</see>
                        method for this
                        semaphore and the current thread is next to be assigned a permit; or
                    </li>
                    <li>
                        Some other thread
                        <see cref="M:System.Threading.Thread.Interrupt">interrupts</see>
                        the current thread; or
                    </li>
                    <li>The specified waiting time elapses.</li>
                </ul>
                <p />
                If a permit is acquired then the value <c>true</c> is returned.
                <p />
                If the specified waiting time elapses then the value
                <c>false</c>
                is returned.  If the time is less than or equal to zero, the method
                will not wait at all.
                <p />
                    If the current thread is <see cref="M:System.Threading.Thread.Interrupt">interrupted</see>
                    while waiting for a permit,
                    then <see cref="T:System.Exception">System.Exception</see>
                    is thrown and the current thread's
                    interrupted status is cleared.
            </remarks>
            <param name="timeout">the maximum time to wait for a permit</param>
            <param name="unit">
                the time unit of the
                <c>timeout</c>
                argument
            </param>
            <returns>
                <c>true</c>
                if a permit was acquired and
                <c>false</c>
                if the waiting time elapsed before a permit was acquired
            </returns>
            <exception cref="T:System.Exception">if the current thread is interrupted</exception>
            <exception cref="T:System.InvalidOperationException">if hazelcast instance is shutdown while waiting</exception>
        </member>
        <member name="M:Hazelcast.Core.ISemaphore.TryAcquire(System.Int32,System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>
                Acquires the given number of permits, if they are available and
                returns immediately, with the value
                <c>true</c>
                ,
                reducing the number of available permits by the given amount.
            </summary>
            <remarks>
                Acquires the given number of permits, if they are available and
                returns immediately, with the value
                <c>true</c> , reducing the number of available permits by the given amount.
                <p />
                If insufficient permits are available then
                the current thread becomes disabled for thread scheduling
                purposes and lies dormant until one of three things happens:
                <ul>
                    <li>
                        Some other thread invokes the
                        <see cref="M:Hazelcast.Core.ISemaphore.Release">Release()</see>
                        method for this
                        semaphore and the current thread is next to be assigned a permit; or
                    </li>
                    <li>
                        Some other thread
                        <see cref="M:System.Threading.Thread.Interrupt">interrupts</see>
                        the current thread; or
                    </li>
                    <li>The specified waiting time elapses.</li>
                </ul>
                <p />
                If the permits are acquired then the value
                <c>true</c>
                is returned.
                <p />
                If the specified waiting time elapses then the value
                <c>false</c>
                is returned.  If the time is less than or equal to zero, the method
                will not wait at all.
                <p />
                <p>
                    If the current thread is <see cref="M:System.Threading.Thread.Interrupt">interrupted</see>
                    while waiting for a permit,
                    then <see cref="T:System.Exception">System.Exception</see>
                    is thrown and the current thread's
                    interrupted status is cleared.
                </p>
            </remarks>
            <param name="permits">the number of permits to acquire</param>
            <param name="timeout">the maximum time to wait for the permits</param>
            <param name="unit">
                the time unit of the
                <c>timeout</c>
                argument
            </param>
            <returns>
                <c>true</c>
                if all permits were acquired and
                <c>false</c>
                if the waiting time elapsed before all permits could be acquired
            </returns>
            <exception cref="T:System.Exception">if the current thread is interrupted</exception>
            <exception cref="T:System.ArgumentException">
                if
                <c>permits</c>
                is negative
            </exception>
            <exception cref="T:System.InvalidOperationException">if hazelcast instance is shutdown while waiting</exception>
        </member>
        <member name="T:Hazelcast.Core.ItemEvent`1">
            <summary>Map Item event.</summary>
            <remarks>Map Item event.</remarks>
            <seealso cref="T:Hazelcast.Core.EntryEvent`2" />
        </member>
        <member name="M:Hazelcast.Core.ItemEvent`1.GetEventType">
            <summary>Returns the event type.</summary>
            <remarks>Returns the event type.</remarks>
            <returns>the event type.</returns>
        </member>
        <member name="M:Hazelcast.Core.ItemEvent`1.GetItem">
            <summary>Returns the item related to event.</summary>
            <remarks>Returns the item related to event.</remarks>
            <returns>the item.</returns>
        </member>
        <member name="M:Hazelcast.Core.ItemEvent`1.GetMember">
            <summary>Returns the member fired this event.</summary>
            <remarks>Returns the member fired this event.</remarks>
            <returns>the member fired this event.</returns>
        </member>
        <member name="T:Hazelcast.Core.ItemEventType">
            <summary>Type of item event.</summary>
            <remarks>Type of item event.</remarks>
        </member>
        <member name="T:Hazelcast.Core.IItemListener`1">
            <summary>
                Item listener for
                <see cref="T:Hazelcast.Core.IQueue`1"/>
                ,
                <see cref="T:Hazelcast.Core.IHSet`1"/>
                and
                <see cref="T:Hazelcast.Core.IHList`1"/>
            </summary>
        </member>
        <member name="M:Hazelcast.Core.IItemListener`1.ItemAdded(Hazelcast.Core.ItemEvent{`0})">
            <summary>Invoked when an item is added.</summary>
            <remarks>Invoked when an item is added.</remarks>
            <param name="item">added item</param>
        </member>
        <member name="M:Hazelcast.Core.IItemListener`1.ItemRemoved(Hazelcast.Core.ItemEvent{`0})">
            <summary>Invoked when an item is removed.</summary>
            <remarks>Invoked when an item is removed.</remarks>
            <param name="item">removed item.</param>
        </member>
        <member name="T:Hazelcast.Core.LifecycleEvent">
            <summary>Lifecycle event fired when IHazelcastInstance's state changes.</summary>
            <remarks>
                Lifecycle event fired when IHazelcastInstance's state changes.
                Events are fired when instance:
                <ul>
                    <li>Starting</li>
                    <li>Started</li>
                    <li>Shutting down</li>
                    <li>Shut down completed</li>
                    <li>Merging</li>
                    <li>Merged</li>
                </ul>
            </remarks>
            <seealso cref="T:Hazelcast.Core.ILifecycleListener">ILifecycleListener</seealso>
            <seealso cref="M:Hazelcast.Core.IHazelcastInstance.GetLifecycleService">IHazelcastInstance.GetLifecycleService()</seealso>
        </member>
        <member name="T:Hazelcast.Core.LifecycleEvent.LifecycleState">
            <summary>lifecycle states</summary>
        </member>
        <member name="T:Hazelcast.Core.ILifecycleListener">
            <summary>Listener object for lisntening lifecycle events of hazelcast instance</summary>
            <seealso cref="T:Hazelcast.Core.LifecycleEvent">LifecycleEvent</seealso>
            <seealso cref="M:Hazelcast.Core.IHazelcastInstance.GetLifecycleService">IHazelcastInstance.GetLifecycleService()</seealso>
        </member>
        <member name="M:Hazelcast.Core.ILifecycleListener.StateChanged(Hazelcast.Core.LifecycleEvent)">
            <summary>Called when instance's state changes</summary>
            <param name="lifecycleEvent">Lifecycle event</param>
        </member>
        <member name="T:Hazelcast.Core.ILifecycleService">
            <summary>
                ILifecycleService allows you to shutdown, terminate and listen to
                <see cref="T:Hazelcast.Core.LifecycleEvent">LifecycleEvent</see>
                's
                on IHazelcastInstance.
            </summary>
        </member>
        <member name="M:Hazelcast.Core.ILifecycleService.AddLifecycleListener(Hazelcast.Core.ILifecycleListener)">
            <summary>Add listener object to listen lifecycle events.</summary>
            <remarks>Add listener object to listen lifecycle events.</remarks>
            <param name="lifecycleListener">Listener object</param>
            <returns>listener id</returns>
        </member>
        <member name="M:Hazelcast.Core.ILifecycleService.IsRunning">
            <summary>whether the instance is running</summary>
            <returns>true if instance is active and running</returns>
        </member>
        <member name="M:Hazelcast.Core.ILifecycleService.RemoveLifecycleListener(System.String)">
            <summary>Remove lifecycle listener</summary>
            <param name="registrationId">
                The listener id returned by
                <see cref="M:Hazelcast.Core.ILifecycleService.AddLifecycleListener(Hazelcast.Core.ILifecycleListener)">AddLifecycleListener(ILifecycleListener)</see>
            </param>
            <returns>true if removed successfully</returns>
        </member>
        <member name="M:Hazelcast.Core.ILifecycleService.Shutdown">
            <summary>gracefully shutdowns IHazelcastInstance.</summary>
            <remarks>
                gracefully shutdowns IHazelcastInstance. Different from
                <see cref="M:Hazelcast.Core.ILifecycleService.Terminate">Terminate()</see>
                , waits partition operations to be completed.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.ILifecycleService.Terminate">
            <summary>terminate IHazelcastInstance ungracefully.</summary>
            <remarks>terminate IHazelcastInstance ungracefully. Does not wait partition operations, forces immediate shutdown.</remarks>
        </member>
        <member name="T:Hazelcast.Core.IManagedContext">
            <summary>Container managed context, such as Spring, Guice and etc.</summary>
            <remarks>Container managed context, such as Spring, Guice and etc.</remarks>
        </member>
        <member name="M:Hazelcast.Core.IManagedContext.Initialize(System.Object)">
            <summary>Initialize the given object instance.</summary>
            <remarks>
                Initialize the given object instance.
                This is intended for repopulating select fields and methods for deserialized instances.
                It is also possible to proxy the object, e.g. with AOP proxies.
            </remarks>
            <param name="obj">Object to initialize</param>
            <returns>the initialized object to use</returns>
        </member>
        <member name="T:Hazelcast.Core.IMember">
            <summary>Cluster member interface.</summary>
            <remarks>
            Cluster member interface. The default implementation violates the Serialization contract.
            It should be serialized/deserialized by Hazelcast.
            </remarks>
            <seealso cref="T:Hazelcast.Core.ICluster">Cluster</seealso>
            <seealso cref="T:Hazelcast.Core.IMembershipListener">MembershipListener</seealso>
        </member>
        <member name="P:Hazelcast.Core.IMember.IsLiteMember">
            <returns>
            <tt>true</tt> if this member is a lite member, <tt>false</tt> otherwise.
            Lite members do not own any partition.
            </returns>
        </member>
        <member name="M:Hazelcast.Core.IMember.GetAttributes">
            <summary>
            Returns configured attributes for this member.<br/>
            <b>This method might not be available on all native clients.</b>
            </summary>
            <returns>Attributes for this member.</returns>
            <since>3.2</since>
        </member>
        <member name="T:Hazelcast.Core.MembershipEvent">
            <summary>
                Membership event fired when a new member is added
                to the cluster and/or when a member leaves the cluster.
            </summary>
            <remarks>
                Membership event fired when a new member is added
                to the cluster and/or when a member leaves the cluster.
            </remarks>
            <seealso cref="T:Hazelcast.Core.IMembershipListener">IMembershipListener</seealso>
        </member>
        <member name="M:Hazelcast.Core.MembershipEvent.GetCluster">
            <summary>Returns the cluster of the event.</summary>
            <remarks>Returns the cluster of the event.</remarks>
            <returns></returns>
        </member>
        <member name="M:Hazelcast.Core.MembershipEvent.GetEventType">
            <summary>Returns the membership event type; #MEMBER_ADDED or #MEMBER_REMOVED</summary>
            <returns>the membership event type</returns>
        </member>
        <member name="M:Hazelcast.Core.MembershipEvent.GetMember">
            <summary>Returns the removed or added member.</summary>
            <remarks>Returns the removed or added member.</remarks>
            <returns>member which is removed/added</returns>
        </member>
        <member name="M:Hazelcast.Core.MembershipEvent.GetMembers">
            <summary>Returns a consistent view of the the members exactly after this MembershipEvent has been processed.</summary>
            <remarks>
                Returns a consistent view of the the members exactly after this MembershipEvent has been processed. So if a
                member is removed, the returned set will not include this member. And if a member is added it will include
                this member.
                The problem with calling the
                <see cref="M:Hazelcast.Core.ICluster.GetMembers">ICluster.GetMembers()</see>
                is that the content could already
                have changed while processing this event so it becomes very difficult to write a deterministic algorithm since
                you can't get a deterministic view of the members. This method solves that problem.
                The set is immutable and ordered. For more information see
                <see cref="M:Hazelcast.Core.ICluster.GetMembers">ICluster.GetMembers()</see>
                .
            </remarks>
            <returns>the members at the moment after this event.</returns>
        </member>
        <member name="T:Hazelcast.Core.IMembershipListener">
            <summary>ICluster membership listener.</summary>
            <remarks>
                ICluster membership listener.
                The IMembershipListener will never be called concurrently and all MembershipListeners will receive the events
                in the same order.
            </remarks>
            <seealso cref="T:Hazelcast.Core.IInitialMembershipListener">IInitialMembershipListener</seealso>
            <seealso cref="M:Hazelcast.Core.ICluster.AddMembershipListener(Hazelcast.Core.IMembershipListener)">ICluster.AddMembershipListener(IMembershipListener)</seealso>
        </member>
        <member name="M:Hazelcast.Core.IMembershipListener.MemberAdded(Hazelcast.Core.MembershipEvent)">
            <summary>Invoked when a new member is added to the cluster.</summary>
            <remarks>Invoked when a new member is added to the cluster.</remarks>
            <param name="membershipEvent">membership event</param>
        </member>
        <member name="M:Hazelcast.Core.IMembershipListener.MemberAttributeChanged(Hazelcast.Core.MemberAttributeEvent)">
            <summary>Invoked when an attribute of a member was changed.</summary>
            <param name="memberAttributeEvent">member attribute event</param>
        </member>
        <member name="M:Hazelcast.Core.IMembershipListener.MemberRemoved(Hazelcast.Core.MembershipEvent)">
            <summary>Invoked when an existing member leaves the cluster.</summary>
            <remarks>Invoked when an existing member leaves the cluster.</remarks>
            <param name="membershipEvent">membership event</param>
        </member>
        <member name="T:Hazelcast.Core.Message`1">
            <summary>
                Message for <see cref="T:Hazelcast.Core.ITopic`1">ITopic&lt;E&gt;</see>.
            </summary>
        </member>
        <member name="M:Hazelcast.Core.Message`1.GetMessageObject">
            <summary>Returns published message</summary>
            <returns>message object</returns>
        </member>
        <member name="M:Hazelcast.Core.Message`1.GetPublishingMember">
            <summary>Returns the member that published the message</summary>
            <returns>publishing member</returns>
        </member>
        <member name="M:Hazelcast.Core.Message`1.GetPublishTime">
            <summary>Return the time when the message is published</summary>
            <returns>publish time</returns>
        </member>
        <member name="T:Hazelcast.Core.IMessageListener`1">
            <summary>
                Message listener for
                <see cref="T:Hazelcast.Core.ITopic`1">ITopic&lt;E&gt;</see>
                .
            </summary>
        </member>
        <member name="M:Hazelcast.Core.IMessageListener`1.OnMessage(Hazelcast.Core.Message{`0})">
            <summary>Invoked when a message is received for the added topic.</summary>
            <remarks>
                Invoked when a message is received for the added topic. Note that topic guarantees message ordering.
                Therefore there is only one thread invoking onMessage. The user shouldn't keep the thread busy and preferably
                dispatch it via an Executor. This will increase the performance of the topic.
            </remarks>
            <param name="message">received message</param>
        </member>
        <member name="T:Hazelcast.Core.IMultiExecutionCallback">
            <summary>
                IMultiExecutionCallback allows to get notified when an execution is completed on each member
                which task is submitted to.
            </summary>
            <remarks>
                IMultiExecutionCallback allows to get notified when an execution is completed on each member
                which task is submitted to. After all executions are completed on all submitted members,
                <see cref="M:Hazelcast.Core.IMultiExecutionCallback.OnComplete(System.Collections.Generic.IDictionary{Hazelcast.Core.IMember,System.Object})" />
                method is called with map of all results.
            </remarks>
            <seealso cref="T:Hazelcast.Core.IExecutorService" />
            <seealso cref="T:Hazelcast.Core.IExecutionCallback`1" />
        </member>
        <member name="M:Hazelcast.Core.IMultiExecutionCallback.OnComplete(System.Collections.Generic.IDictionary{Hazelcast.Core.IMember,System.Object})">
            <summary>Called after all executions are completed.</summary>
            <remarks>Called after all executions are completed.</remarks>
            <param name="values">map of IMember-Response pairs</param>
        </member>
        <member name="M:Hazelcast.Core.IMultiExecutionCallback.OnResponse(Hazelcast.Core.IMember,System.Object)">
            <summary>Called when an execution is completed on a member.</summary>
            <remarks>Called when an execution is completed on a member.</remarks>
            <param name="member">member which task is submitted to.</param>
            <param name="value">result of execution</param>
        </member>
        <member name="T:Hazelcast.Core.IPartition">
            <summary>Virtual partition instance.</summary>
            <remarks>
                Virtual partition instance.
                Each partition belongs to a member and this ownership may change when a member joins to or leaves the cluster.
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.IPartition.GetOwner">
            <summary>Returns owner member of the partition.</summary>
            <remarks>Returns owner member of the partition.</remarks>
            <returns>owner member of the partition</returns>
        </member>
        <member name="M:Hazelcast.Core.IPartition.GetPartitionId">
            <summary>Returns id of the partition.</summary>
            <remarks>Returns id of the partition.</remarks>
            <returns>id of the partition</returns>
        </member>
        <member name="T:Hazelcast.Core.IPartitionAware`1">
            <summary>
                IPartitionAware allows implementing keys to be located on the same member
                or implementing tasks to be executed on
                <see cref="M:Hazelcast.Core.IPartitionAware`1.GetPartitionKey">IPartitionAware&lt;T&gt;.GetPartitionKey()</see>
                's owner member.
                This makes related data to be stored in the same location. (See data-affinity.)
            </summary>
        </member>
        <member name="M:Hazelcast.Core.IPartitionAware`1.GetPartitionKey">
            <summary>The key object that will be used by Hazelcast to specify the partition.</summary>
            <remarks>
                The key object that will be used by Hazelcast to specify the partition.
                You should give the same key for objects that you want them to locate in the same partition.
            </remarks>
            <returns>partition key</returns>
        </member>
        <member name="T:Hazelcast.Core.IPartitioningStrategy">
            <summary>
                IPartitioningStrategy allows keys to be located on the same member
                This makes related data to be stored in the same location.
            </summary>
            <remarks>
                IPartitioningStrategy allows keys to be located on the same member
                This makes related data to be stored in the same location. (See data-affinity.)
            </remarks>
        </member>
        <member name="M:Hazelcast.Core.IPartitioningStrategy.GetPartitionKey(System.Object)">
            <summary>Returns the key object that will be used by Hazelcast to specify the partition.</summary>
            <remarks>Returns the key object that will be used by Hazelcast to specify the partition.</remarks>
            <param name="key">actual key object</param>
            <returns>partition key object or null to fallback to default partition calculation</returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IData">
            <summary>Data is basic unit of serialization.</summary>
            <remarks>
            Data is basic unit of serialization. It stores binary form of an object serialized
            </remarks>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IData.DataSize">
            <summary>Returns size of internal binary data in bytes</summary>
            <returns>internal data size</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IData.GetHeapCost">
            <summary>Returns approximate heap cost of this Data object in bytes.</summary>
            <returns>approximate heap cost</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IData.GetPartitionHash">
            <summary>Returns partition hash calculated for serialized object.</summary>
            <remarks>
            Returns partition hash calculated for serialized object.
            Partition hash is used to determine partition of a Data and is calculated using
            <see cref="T:Hazelcast.Core.IPartitioningStrategy"/>
            during serialization.
            <p/>
            If partition hash is not set then standard <tt>hashCode()</tt> is used.
            </remarks>
            <returns>partition hash</returns>
            <seealso cref="T:Hazelcast.Core.IPartitionAware`1"/>
            <seealso cref="T:Hazelcast.Core.IPartitioningStrategy"/>
            <seealso cref="M:Hazelcast.IO.Serialization.SerializationService.ToData(System.Object,Hazelcast.Core.IPartitioningStrategy)"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IData.GetTypeId">
            <summary>Returns serialization type of binary form.</summary>
            <remarks>
            Returns serialization type of binary form. It's defined by
            <see cref="M:Hazelcast.IO.Serialization.ISerializer.GetTypeId"/>
            </remarks>
            <returns>serializer type id</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IData.HasPartitionHash">
            <summary>Returns true if Data has partition hash, false otherwise.</summary>
            <returns>true if Data has partition hash, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IData.IsPortable">
            <summary>
            Returns true if this Data is created from a
            <see cref="T:Hazelcast.IO.Serialization.IPortable"/>
            object,
            false otherwise.
            </summary>
            <returns>true if source object is <tt>Portable</tt>, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IData.ToByteArray">
            <summary>Returns byte array representation of internal binary format.</summary>
            <returns>binary data</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IData.TotalSize">
            <summary>Returns the total size of Data in bytes</summary>
            <returns>total size</returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IDataSerializable">
            <summary>DataSerializable is a serialization method as an alternative to standard serialization.
            	</summary>
            <remarks>
            DataSerializable is a serialization method as an alternative to standard serialization.
            </remarks>
            <seealso cref="T:Hazelcast.IO.Serialization.IIdentifiedDataSerializable">IIdentifiedDataSerializable</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortable">IPortable</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IVersionedPortable">IVersionedPortable</seealso>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IDataSerializable.GetJavaClassName">
            <summary>
            Get Server Java Impl class full name
            </summary>
            <returns>full java class name</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IDataSerializable.ReadData(Hazelcast.IO.IObjectDataInput)">
            <summary>Reads fields from the input stream</summary>
            <param name="input">input</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IDataSerializable.WriteData(Hazelcast.IO.IObjectDataOutput)">
            <summary>Writes object fields to output stream</summary>
            <param name="output">output</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ISerializerHook`1.CreateSerializer">
            <summary>Creates a new serializer for the serialization type</summary>
            <returns>a new serializer instance</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ISerializerHook`1.GetSerializationType">
            <summary>Returns the actual class type of the serialized object</summary>
            <returns>the serialized object type</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ISerializerHook`1.IsOverwritable">
            <summary>
            Defines if this serializer can be overridden by defining a custom
            serializer in the configurations (codebase or configuration file)
            </summary>
            <returns>if the serializer is overwritable</returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IVersionedPortable">
            <summary>
            VersionedPortable is an extension to
            <see cref="T:Hazelcast.IO.Serialization.IPortable">IPortable</see>
            to support per class version instead of a global serialization version.
            </summary>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortable">IPortable</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortableFactory">IPortableFactory</seealso>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IVersionedPortable.GetClassVersion">
            <summary>Returns version for this Portable class</summary>
            <returns>class version</returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.JavaClass">
            <summary>
             Class for serializing/deserializing Java Class types
            </summary>
        </member>
        <member name="T:Hazelcast.IO.Serialization.JavaEnum">
            <summary>
             Class for serializing/deserializing Java enums
            </summary>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.Read(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadBoolean">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadBoolean(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadByte">
            <summary>
                See the general contract of the <code>readByte</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readByte</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>
                the next byte of this input stream as a signed 8-bit
                <code>byte</code>.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream has reached the end.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadByte(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadChar">
            <summary>
                See the general contract of the <code>readChar</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readChar</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>the next two bytes of this input stream as a Unicode character.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream reaches the end before reading two
                bytes.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadChar(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadDouble">
            <summary>
                See the general contract of the <code>readDouble</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readDouble</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>
                the next eight bytes of this input stream, interpreted as a
                <code>double</code>.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream reaches the end before reading eight
                bytes.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadDouble(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadFloat">
            <summary>
                See the general contract of the <code>readFloat</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readFloat</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>
                the next four bytes of this input stream, interpreted as a
                <code>float</code>.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream reaches the end before reading four
                bytes.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadFloat(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadFully(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadFully(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadInt">
            <summary>
                See the general contract of the <code>readInt</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readInt</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>
                the next four bytes of this input stream, interpreted as an
                <code>int</code>.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream reaches the end before reading four
                bytes.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadInt(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadLong">
            <summary>
                See the general contract of the <code>readLong</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readLong</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>
                the next eight bytes of this input stream, interpreted as a
                <code>long</code>.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream reaches the end before reading eight
                bytes.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadLong(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadShort">
            <summary>
                See the general contract of the <code>readShort</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readShort</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>
                the next two bytes of this input stream, interpreted as a signed
                16-bit number.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream reaches the end before reading two
                bytes.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadShort(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadByteArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadCharArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadIntArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadLongArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadDoubleArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadFloatArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadShortArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadUnsignedByte">
            <summary>
                See the general contract of the <code>readUnsignedByte</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readUnsignedByte</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>
                the next byte of this input stream, interpreted as an unsigned
                8-bit number.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream has reached the end.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadUnsignedShort">
            <summary>
                See the general contract of the <code>readUnsignedShort</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readUnsignedShort</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>
                the next two bytes of this input stream, interpreted as an
                unsigned 16-bit integer.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream reaches the end before reading two
                bytes.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadUTF">
            <summary>
                See the general contract of the <code>readUTF</code> method of
                <code>DataInput</code>.
            </summary>
            <remarks>
                See the general contract of the <code>readUTF</code> method of
                <code>DataInput</code>.
                <p />
                Bytes for this operation are read from the contained input stream.
            </remarks>
            <returns>a Unicode string.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
                if this input stream reaches the end before reading all
                the bytes.
            </exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
            <exception cref="T:System.IO.InvalidDataException">
                if the bytes do not represent a valid modified UTF-8
                encoding of a string.
            </exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadData">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.Position">
            <summary>Returns this buffer's position.</summary>
            <remarks>Returns this buffer's position.</remarks>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.ReadLine">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataInput.CheckAvailable(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteBoolean(System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteBoolean(System.Int32,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteByte(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteByte(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteBytes(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteChar(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteChar(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteChars(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteDouble(System.Double)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteDouble(System.Int32,System.Double)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteFloat(System.Single)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteFloat(System.Int32,System.Single)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteInt(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteInt(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteLong(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteLong(System.Int32,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteShort(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteShort(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteUTF(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteByteArray(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteBooleanArray(System.Boolean[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteCharArray(System.Char[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteIntArray(System.Int32[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteLongArray(System.Int64[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteDoubleArray(System.Double[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteFloatArray(System.Single[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteShortArray(System.Int16[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteUTFArray(System.String[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteObject(System.Object)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.WriteData(Hazelcast.IO.Serialization.IData)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArrayObjectDataOutput.Position">
            <summary>Returns this buffer's position.</summary>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IByteArraySerializer`1">
            <summary>
            For sample usage custom serialization and other way of custom serialization
            see
            <see cref="T:Hazelcast.IO.Serialization.IStreamSerializer`1">IStreamSerializer&lt;T&gt;</see>
            .
            Note that read and write methods should be compatible
            </summary>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IByteArraySerializer`1.Read(System.Byte[])">
            <summary>Converts given byte array to object</summary>
            <param name="buffer">that object will be read from</param>
            <returns>deserialized object</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IByteArraySerializer`1.Write(`0)">
            <summary>Converts given object to byte array</summary>
            <param name="obj">that will be serialized</param>
            <returns>byte array that object is serialized into</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArraySerializerAdapter`1.Write(Hazelcast.IO.IObjectDataOutput,System.Object)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ByteArraySerializerAdapter`1.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IClassDefinition">
            <summary>ClassDefinition defines a class schema for Portable classes.</summary>
            <remarks>
            ClassDefinition defines a class schema for Portable classes. It allows to query field names, types, class id etc.
            It can be created manually using
            <see cref="T:Hazelcast.IO.Serialization.ClassDefinitionBuilder"/>
            or ondemand during serialization phase.
            </remarks>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortable"/>
            <seealso cref="T:Hazelcast.IO.Serialization.ClassDefinitionBuilder"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetClassId">
            <returns>class id</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetFactoryId">
            <returns>factory id</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetField(System.String)">
            <param name="name">name of the field</param>
            <returns>field definition by given name or null</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetField(System.Int32)">
            <param name="fieldIndex">index of the field</param>
            <returns>field definition by given index</returns>
            <exception cref="T:System.IndexOutOfRangeException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetFieldClassId(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>class id of given field</returns>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetFieldCount">
            <returns>total field count</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetFieldNames">
            <returns>all field names contained in this class definition</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetFieldType(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>type of given field</returns>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.GetVersion">
            <returns>version</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IClassDefinition.HasField(System.String)">
            <param name="fieldName">field name</param>
            <returns>true if this class definition contains a field named by given name</returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.ClassDefinitionBuilder">
            <summary>
                ClassDefinitionBuilder is used to build and register ClassDefinitions manually.
            </summary>
            <remarks>
                ClassDefinitionBuilder is used to build and register ClassDefinitions manually.
            </remarks>
            <seealso cref="T:Hazelcast.IO.Serialization.IClassDefinition">IClassDefinition</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortable">IPortable</seealso>
            <seealso cref="M:Hazelcast.Config.SerializationConfig.AddClassDefinition(Hazelcast.IO.Serialization.IClassDefinition)">
                Hazelcast.Config.SerializationConfig.AddClassDefinition(IClassDefinition)
            </seealso>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteBoolean(System.String,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteByte(System.String,System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteChar(System.String,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteDouble(System.String,System.Double)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteFloat(System.String,System.Single)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteShort(System.String,System.Int16)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteBooleanArray(System.String,System.Boolean[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteByteArray(System.String,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteCharArray(System.String,System.Char[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteIntArray(System.String,System.Int32[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteLongArray(System.String,System.Int64[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteDoubleArray(System.String,System.Double[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteFloatArray(System.String,System.Single[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteShortArray(System.String,System.Int16[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteUTFArray(System.String,System.String[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WritePortable(System.String,Hazelcast.IO.Serialization.IPortable)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WriteNullPortable(System.String,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.WritePortableArray(System.String,Hazelcast.IO.Serialization.IPortable[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ClassDefinitionWriter.CreateNestedClassDef(Hazelcast.IO.Serialization.IPortable,Hazelcast.IO.Serialization.ClassDefinitionBuilder)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.BooleanSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.BooleanSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.BooleanArraySerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.BooleanArraySerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Boolean[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.ByteSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.ByteSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.CharArraySerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.CharArraySerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Char[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.CharSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.CharSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Char)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.DoubleArraySerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.DoubleArraySerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Double[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.DoubleSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.DoubleSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Double)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.FloatArraySerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.FloatArraySerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Single[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.FloatSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.FloatSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Single)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.IntegerArraySerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.IntegerArraySerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Int32[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.IntegerSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.IntegerSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.LongArraySerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.LongArraySerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Int64[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.LongSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.LongSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.ShortArraySerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.ShortArraySerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Int16[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.ShortSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.ShortSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.Int16)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.StringSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.StringSerializer.Write(Hazelcast.IO.IObjectDataOutput,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.StringArraySerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.StringArraySerializer.Write(Hazelcast.IO.IObjectDataOutput,System.String[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.ByteArraySerializer.Write(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ConstantSerializers.ByteArraySerializer.Read(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IDataSerializableFactory">
            <summary>DataSerializableFactory is used to create IdentifiedDataSerializable instances during de-serialization.</summary>
            <seealso cref="T:Hazelcast.IO.Serialization.IIdentifiedDataSerializable">IIdentifiedDataSerializable</seealso>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IDataSerializableFactory.Create(System.Int32)">
            <summary>Creates an IdentifiedDataSerializable instance using given type id</summary>
            <param name="typeId">IdentifiedDataSerializable type id</param>
            <returns>IdentifiedDataSerializable instance or null if type id is not known by this factory</returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.DataSerializer">
            <summary>
                This class is the default serializer for all types that are serialized using Hazelcast
                internal methods.
            </summary>
            <remarks>
                This class is the default serializer for all types that are serialized using Hazelcast
                internal methods. 
                If the way the DataSerializer serializes values is changed the extract method needs to be changed too!
            </remarks>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DataSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DataSerializer.Write(Hazelcast.IO.IObjectDataOutput,Hazelcast.IO.Serialization.IIdentifiedDataSerializable)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadInt(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadLong(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadUTF(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadBoolean(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadByte(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadChar(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadDouble(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadFloat(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadShort(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadBooleanArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadByteArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadCharArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadIntArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadLongArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadDoubleArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadFloatArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadShortArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadUTFArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadPortable``1(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadPortableArray(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.GetRawDataInput">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.End">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadNestedPosition(System.String,Hazelcast.IO.Serialization.FieldType)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadPosition(System.String,Hazelcast.IO.Serialization.FieldType)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableReader.ReadPosition(Hazelcast.IO.Serialization.IFieldDefinition)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.#ctor(Hazelcast.IO.Serialization.PortableSerializer,Hazelcast.IO.IBufferObjectDataOutput,Hazelcast.IO.Serialization.IClassDefinition)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteInt(System.String,System.Int32)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteLong(System.String,System.Int64)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteUTF(System.String,System.String)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteBoolean(System.String,System.Boolean)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteByte(System.String,System.Byte)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteChar(System.String,System.Int32)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteDouble(System.String,System.Double)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteFloat(System.String,System.Single)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteShort(System.String,System.Int16)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WritePortable(System.String,Hazelcast.IO.Serialization.IPortable)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteNullPortable(System.String,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteBooleanArray(System.String,System.Boolean[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteByteArray(System.String,System.Byte[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteCharArray(System.String,System.Char[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteIntArray(System.String,System.Int32[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteLongArray(System.String,System.Int64[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteDoubleArray(System.String,System.Double[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteFloatArray(System.String,System.Single[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteShortArray(System.String,System.Int16[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WriteUTFArray(System.String,System.String[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.WritePortableArray(System.String,Hazelcast.IO.Serialization.IPortable[])">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.GetRawDataOutput">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.End">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.DefaultPortableWriter.SetPosition(System.String,Hazelcast.IO.Serialization.FieldType)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="T:Hazelcast.IO.Serialization.DefaultSerializers.SerializableSerializer">
            <summary>
            Serialize using default .NET serialization
            </summary>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteObject(System.Object)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteData(Hazelcast.IO.Serialization.IData)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.Write(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteBoolean(System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteByte(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteShort(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteChar(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteInt(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteLong(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteFloat(System.Single)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteDouble(System.Double)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteBytes(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteChars(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteUTF(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteByteArray(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteCharArray(System.Char[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteIntArray(System.Int32[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteLongArray(System.Int64[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteDoubleArray(System.Double[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteFloatArray(System.Single[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.WriteShortArray(System.Int16[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.EmptyObjectDataOutput.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IFieldDefinition">
            <summary>FieldDefinition defines name, type, index of a field</summary>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IFieldDefinition.GetClassId">
            <returns>class id of this field's class</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IFieldDefinition.GetFactoryId">
            <returns>factory id of this field's class</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IFieldDefinition.GetFieldType">
            <returns>field type</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IFieldDefinition.GetIndex">
            <returns>field index</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IFieldDefinition.GetName">
            <returns>field name</returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.HazelcastSerializationException">
            <summary>This is an exception thrown when an exception occurs while serializing/deserializing objects.</summary>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IIdentifiedDataSerializable">
            <summary>
            IIdentifiedDataSerializable is a serialization method as an alternative to standard serialization.
            It uses a factory to avoid reflection during deserialization.
            <see cref="T:Hazelcast.IO.Serialization.IDataSerializableFactory">IDataSerializableFactory</see>
            </summary>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortable">IPortable</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IDataSerializableFactory">IDataSerializableFactory</seealso>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IIdentifiedDataSerializable.ReadData(Hazelcast.IO.IObjectDataInput)">
            <summary>Reads fields from the input stream</summary>
            <param name="input">input</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IIdentifiedDataSerializable.WriteData(Hazelcast.IO.IObjectDataOutput)">
            <summary>Writes object fields to output stream</summary>
            <param name="output">output</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IIdentifiedDataSerializable.GetFactoryId">
            <summary>Returns DataSerializableFactory factory id for this class.</summary>
            <remarks>Returns DataSerializableFactory factory id for this class.</remarks>
            <returns>factory id</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IIdentifiedDataSerializable.GetId">
            <summary>Returns type identifier for this class.</summary>
            <remarks>Returns type identifier for this class. Id should be unique per DataSerializableFactory.
            	</remarks>
            <returns>type id</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadBoolean(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadByte(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadByteArray(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadChar(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadCharArray(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadDouble(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadDoubleArray(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadFloat(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadFloatArray(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadInt(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadIntArray(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadLong(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadLongArray(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadPortable``1(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadPortableArray(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadShort(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadShortArray(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.MorphingPortableReader.ReadUTF(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IPortable">
            <summary>Portable provides an alternative serialization method.</summary>
            <remarks>
            Portable provides an alternative serialization method. Instead of relying on reflection, each Portable is
            created by a registere <see cref="T:Hazelcast.IO.Serialization.IPortableFactory" />.
            <p />
            Portable serialization that have the following advantages:
            <ul>
            <li>Support multiversion of the same object type.
            (See
            <see cref="M:Hazelcast.Config.SerializationConfig.SetPortableVersion(System.Int32)" />
            )</li>
            <li>Fetching individual fields without having to rely on reflection.</li>
            <li>Querying and indexing support without de-serialization and/or reflection.</li>
            </ul>
            </remarks>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortableFactory">IPortableFactory</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortableWriter">IPortableWriter</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortableReader">IPortableReader</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IClassDefinition">IClassDefinition</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IIdentifiedDataSerializable">IIdentifiedDataSerializable</seealso>
            <seealso cref="T:Hazelcast.Config.SerializationConfig">Hazelcast.Config.SerializationConfig
            	</seealso>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortable.GetClassId">
            <summary>Returns class identifier for this portable class.</summary>
            <remarks>Returns class identifier for this portable class. Class id should be unique per PortableFactory.
            	</remarks>
            <returns>class id</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortable.GetFactoryId">
            <summary>Returns PortableFactory id for this portable class</summary>
            <returns>factory id</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortable.ReadPortable(Hazelcast.IO.Serialization.IPortableReader)">
            <summary>Read portable fields using PortableReader</summary>
            <param name="reader">PortableReader</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortable.WritePortable(Hazelcast.IO.Serialization.IPortableWriter)">
            <summary>Serialize this portable object using PortableWriter</summary>
            <param name="writer">PortableWriter</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IPortableFactory">
            <summary>PortableFactory is used to create Portable instances during de-serialization.
            	</summary>
            <remarks>PortableFactory is used to create Portable instances during de-serialization.
            	</remarks>
            <seealso cref="T:Hazelcast.IO.Serialization.IPortable">IPortable</seealso>
            <seealso cref="T:Hazelcast.IO.Serialization.IVersionedPortable">IVersionedPortable</seealso>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableFactory.Create(System.Int32)">
            <summary>Creates a Portable instance using given class id</summary>
            <param name="classId">portable class id</param>
            <returns>portable instance or null if class id is not known by this factory</returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IPortableReader">
            <summary>
            Provides a mean of reading portable fields from a binary in form of primitives, arrays of primitives , nested portable fields and array of portable fields.
            </summary>
            <remarks>
            Provides a mean of reading portable fields from a binary in form of primitives, arrays of primitives , nested portable fields and array of portable fields.
            </remarks>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.GetFieldClassId(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>classId of given field</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.GetFieldNames">
            <returns>set of field names on this portable class</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.GetFieldType(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>field type of given fieldName</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.GetRawDataInput">
            <summary>
            <see cref="M:Hazelcast.IO.Serialization.IPortableWriter.GetRawDataOutput">IPortableWriter.GetRawDataOutput()</see>
            .
            <p/>
            Note that portable fields can not read after GetRawDataInput() is called. In case this happens,
            IOException will be thrown.
            </summary>
            <returns>rawDataInput</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.GetVersion">
            <returns>version global version of portable classes</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.HasField(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>true if field exist in this class.</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadBoolean(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the boolean value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadBooleanArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the boolean array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadByte(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the byte value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadByteArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the byte array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadChar(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the char value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadCharArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the char array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadDouble(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the double value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadDoubleArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the double array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadFloat(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the float value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadFloatArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the float array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadInt(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the int value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadIntArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the int array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadLong(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the long value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadLongArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the long array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadPortable``1(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the portable value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadPortableArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the portabke value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadShort(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the short value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadShortArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the short array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadUTF(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the utf string value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableReader.ReadUTFArray(System.String)">
            <param name="fieldName">name of the field</param>
            <returns>the string array value read</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableSerializer.Write(Hazelcast.IO.IObjectDataOutput,Hazelcast.IO.Serialization.IPortable)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableSerializer.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableSerializer.CreateReader(Hazelcast.IO.IBufferObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableSerializer.ReadAndInitialize(Hazelcast.IO.IBufferObjectDataInput,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableSerializer.WriteInternal(Hazelcast.IO.IBufferObjectDataOutput,Hazelcast.IO.Serialization.IPortable)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableSerializer.Read(Hazelcast.IO.IBufferObjectDataInput,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IPortableWriter">
            <summary>
            Provides a mean of writing portable fields to a binary in form of primitives, arrays of  primitives , nested portable fields and array of portable fields.
            </summary>
            <remarks>
            Provides a mean of writing portable fields to a binary in form of primitives, arrays of  primitives , nested portable fields and array of portable fields.
            </remarks>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.GetRawDataOutput">
            <summary>
            After writing portable fields, one can write remaining fields in old fashioned way consecutively at the end
            of stream.
            </summary>
            <remarks>
            After writing portable fields, one can write remaining fields in old fashioned way consecutively at the end
            of stream. User should not that after getting raw dataoutput trying to write portable fields will result
            in IOException
            </remarks>
            <returns>ObjectDataOutput</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteBoolean(System.String,System.Boolean)">
            <summary>Writes a primitive boolean.</summary>
            <remarks>Writes a primitive boolean.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">int value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteBooleanArray(System.String,System.Boolean[])">
            <summary>Writes a primitive boolean-array.</summary>
            <remarks>Writes a primitive boolean-array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="bools">boolean array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteByte(System.String,System.Byte)">
            <summary>Writes a primitive byte.</summary>
            <remarks>Writes a primitive byte.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">int value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteByteArray(System.String,System.Byte[])">
            <summary>Writes a primitive byte-array.</summary>
            <remarks>Writes a primitive byte-array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="bytes">byte array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteChar(System.String,System.Int32)">
            <summary>Writes a primitive char.</summary>
            <remarks>Writes a primitive char.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">int value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteCharArray(System.String,System.Char[])">
            <summary>Writes a primitive char-array.</summary>
            <remarks>Writes a primitive char-array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="chars">char array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteDouble(System.String,System.Double)">
            <summary>Writes a primitive double.</summary>
            <remarks>Writes a primitive double.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">int value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteDoubleArray(System.String,System.Double[])">
            <summary>Writes a primitive double array.</summary>
            <remarks>Writes a primitive double array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="values">double array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteFloat(System.String,System.Single)">
            <summary>Writes a primitive float.</summary>
            <remarks>Writes a primitive float.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">int value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteFloatArray(System.String,System.Single[])">
            <summary>Writes a primitive float array.</summary>
            <remarks>Writes a primitive float array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="values">float array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteInt(System.String,System.Int32)">
            <summary>Writes a primitive int.</summary>
            <remarks>Writes a primitive int.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">int value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteIntArray(System.String,System.Int32[])">
            <summary>Writes a primitive int-array.</summary>
            <remarks>Writes a primitive int-array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="ints">int array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteLong(System.String,System.Int64)">
            <summary>Writes a primitive long.</summary>
            <remarks>Writes a primitive long.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">long value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteLongArray(System.String,System.Int64[])">
            <summary>Writes a primitive long-array.</summary>
            <remarks>Writes a primitive long-array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="longs">long array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteNullPortable(System.String,System.Int32,System.Int32)">
            <summary>To write a null portable value, user needs to provide class and factoryIds of related class.
            	</summary>
            <remarks>To write a null portable value, user needs to provide class and factoryIds of related class.
            	</remarks>
            <param name="fieldName">name of the field</param>
            <param name="factoryId">factory id of related portable class</param>
            <param name="classId">class id of related portable class</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WritePortable(System.String,Hazelcast.IO.Serialization.IPortable)">
            <summary>Writes a Portable.</summary>
            <remarks>Writes a Portable.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="portable">Portable to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WritePortableArray(System.String,Hazelcast.IO.Serialization.IPortable[])">
            <summary>Writes a an array of Portables.</summary>
            <remarks>Writes a an array of Portables.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="portables">portable array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteShort(System.String,System.Int16)">
            <summary>Writes a primitive short.</summary>
            <remarks>Writes a primitive short.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">int value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteShortArray(System.String,System.Int16[])">
            <summary>Writes a primitive short-array.</summary>
            <remarks>Writes a primitive short-array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="values">short array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteUTF(System.String,System.String)">
            <summary>Writes an UTF string.</summary>
            <remarks>Writes an UTF string.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="value">utf string value to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableWriter.WriteUTFArray(System.String,System.String[])">
            <summary>Writes a primitive string-array.</summary>
            <remarks>Writes a primitive string-array.</remarks>
            <param name="fieldName">name of the field</param>
            <param name="strings">string array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableContext.LookupClassDefinition(Hazelcast.IO.Serialization.IData)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.IPortableContext.LookupOrRegisterClassDefinition(Hazelcast.IO.Serialization.IPortable)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableContext.LookupClassDefinition(Hazelcast.IO.Serialization.IData)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableContext.LookupOrRegisterClassDefinition(Hazelcast.IO.Serialization.IPortable)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.PortableContext.ReadClassDefinition(Hazelcast.IO.IBufferObjectDataInput,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException" />
        </member>
        <member name="M:Hazelcast.IO.Serialization.ISerializationService.CreatePortableReader(Hazelcast.IO.Serialization.IData)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.SerializationService.CreatePortableReader(Hazelcast.IO.Serialization.IData)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.SerializationService.SerializerFor(System.Object)">
            <summary>
            Searches for a serializer for the provided object
            Serializers will be  searched in this order;
             1-NULL serializer
             2-Default serializers, like primitives, arrays, String and some C# types
             3-Custom registered types by user
             4-CLR serialization if type is Serializable
             5-Global serializer if registered by user
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Hazelcast.IO.Serialization.ISerializer">
            <summary>
            Base interface of custom serialization interfaces
            <p/>
            see
            <see cref="T:Hazelcast.IO.Serialization.IByteArraySerializer`1">IByteArraySerializer&lt;T&gt;</see>
            see
            <see cref="T:Hazelcast.IO.Serialization.IStreamSerializer`1">IStreamSerializer&lt;T&gt;</see>
            </summary>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ISerializer.Destroy">
            <summary>Called when instance is shutting down.</summary>
            <remarks>Called when instance is shutting down. It can be used to clear used resources.
            	</remarks>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ISerializer.GetTypeId">
            <returns>typeId of serializer</returns>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ISerializerAdapter.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.ISerializerAdapter.Write(Hazelcast.IO.IObjectDataOutput,System.Object)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.IO.Serialization.IStreamSerializer`1">
            <summary>A base class for custom serialization.</summary>
            <remarks>
            A base class for custom serialization. User can register custom serializer.
            </remarks>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IStreamSerializer`1.Read(Hazelcast.IO.IObjectDataInput)">
            <summary>Reads object from objectDataInputStream</summary>
            <param name="input">ObjectDataInput stream that object will read from</param>
            <returns>read object</returns>
            <exception cref="T:System.IO.IOException">in case of failure to read</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.IStreamSerializer`1.Write(Hazelcast.IO.IObjectDataOutput,`0)">
            <summary>This method writes object to ObjectDataOutput</summary>
            <param name="output">ObjectDataOutput stream that object will be written to</param>
            <param name="obj">that will be written to out</param>
            <exception cref="T:System.IO.IOException">in case of failure to write</exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.StreamSerializerAdapter`1.Write(Hazelcast.IO.IObjectDataOutput,System.Object)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.Serialization.StreamSerializerAdapter`1.Read(Hazelcast.IO.IObjectDataInput)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.IO.Bits">
            <summary>Access and manipulate bits, bytes, primitives ...</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.ByteSizeInBytes">
            <summary>Byte size in bytes</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.BooleanSizeInBytes">
            <summary>Boolean size in bytes</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.ShortSizeInBytes">
            <summary>Short size in bytes</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.CharSizeInBytes">
            <summary>Char size in bytes</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.IntSizeInBytes">
            <summary>Integer size in bytes</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.FloatSizeInBytes">
            <summary>Float size in bytes</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.LongSizeInBytes">
            <summary>Long size in bytes</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.DoubleSizeInBytes">
            <summary>Double size in bytes</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.CacheLineLength">
            <summary>Length of the data blocks used by the CPU cache sub-system in bytes.</summary>
        </member>
        <member name="F:Hazelcast.IO.Bits.NullArray">
            <summary>for null arrays, this value writen to stream to represent null array size.</summary>
        </member>
        <member name="M:Hazelcast.IO.Bits.ClearBit(System.Byte,System.Int32)">
            <summary>Clears n-th bit of the byte value</summary>
            <param name="value">byte value</param>
            <param name="bit">n-th bit</param>
            <returns>value</returns>
        </member>
        <member name="M:Hazelcast.IO.Bits.ClearBit(System.Int32,System.Int32)">
            <summary>Clears n-th bit of the integer value</summary>
            <param name="value">integer value</param>
            <param name="bit">n-th bit</param>
            <returns>value</returns>
        </member>
        <member name="M:Hazelcast.IO.Bits.CombineToInt(System.Int16,System.Int16)">
            <summary>Combines two short integer values into an integer.</summary>
        </member>
        <member name="M:Hazelcast.IO.Bits.CombineToLong(System.Int32,System.Int32)">
            <summary>Combines two integer values into a long integer.</summary>
        </member>
        <member name="M:Hazelcast.IO.Bits.InvertBit(System.Byte,System.Int32)">
            <summary>Inverts n-th bit of the byte value</summary>
            <param name="value">byte value</param>
            <param name="bit">n-th bit</param>
            <returns>value</returns>
        </member>
        <member name="M:Hazelcast.IO.Bits.InvertBit(System.Int32,System.Int32)">
            <summary>Inverts n-th bit of the integer value</summary>
            <param name="value">integer value</param>
            <param name="bit">n-th bit</param>
            <returns>value</returns>
        </member>
        <member name="M:Hazelcast.IO.Bits.IsBitSet(System.Int32,System.Int32)">
            <summary>Returns true if n-th bit of the value is set, false otherwise</summary>
        </member>
        <member name="M:Hazelcast.IO.Bits.SetBit(System.Byte,System.Int32)">
            <summary>Sets n-th bit of the byte value</summary>
            <param name="value">byte value</param>
            <param name="bit">n-th bit</param>
            <returns>value</returns>
        </member>
        <member name="M:Hazelcast.IO.Bits.SetBit(System.Int32,System.Int32)">
            <summary>Sets n-th bit of the integer value</summary>
            <param name="value">integer value</param>
            <param name="bit">n-th bit</param>
            <returns>value</returns>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadBoolean">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadByte">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadChar">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadDouble">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadFloat">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadFully(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadFully(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadInt">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadLong">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadShort">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadUnsignedByte">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadUnsignedShort">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.ReadUTF">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataInput.SkipBytes(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.Write(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteBoolean(System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteByte(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteBytes(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteChar(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteChars(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteDouble(System.Double)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteFloat(System.Single)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteInt(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteLong(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteShort(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Hazelcast.IO.IDataOutput.WriteUTF(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.IO.ISocketReadable">
            <summary>Represents something where data can be read from.</summary>
            <remarks>Represents something where data can be read from.</remarks>
        </member>
        <member name="T:Hazelcast.IO.ISocketWritable">
            <summary>
            Represents something that can be written to a
            <see cref="T:Hazelcast.Client.Connection.ClientConnection">Clientconnection</see>.
            </summary>
        </member>
        <member name="M:Hazelcast.IO.ISocketWritable.IsUrgent">
            <summary>Checks if this SocketWritable is urgent.</summary>
            <remarks>
            Checks if this SocketWritable is urgent.
            SocketWritable that are urgent, have priority above regular SocketWritable. This is useful to implement
            System Operations so that they can be send faster than regular operations; especially when the system is
            under load you want these operations have precedence.
            </remarks>
            <returns>true if urgent, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.IO.ISocketWritable.WriteTo(Hazelcast.Net.Ext.ByteBuffer)">
            <summary>Asks the SocketWritable to write its content to the destination ByteBuffer.
            	</summary>
            <remarks>Asks the SocketWritable to write its content to the destination ByteBuffer.
            	</remarks>
            <param name="destination">the ByteBuffer to write to.</param>
            <returns>todo: unclear what return value means.</returns>
        </member>
        <member name="T:Hazelcast.IO.Address">
            <summary>Represents an address of a member in the cluster.</summary>
            <remarks>Represents an address of a member in the cluster.</remarks>
        </member>
        <member name="M:Hazelcast.IO.Address.#ctor(System.Net.IPEndPoint)">
            <summary>Creates a new Address</summary>
            <param name="inetSocketAddress">the InetSocketAddress to use</param>
            <exception cref="T:System.ArgumentNullException">if inetSocketAddress is null</exception>
            <exception cref="T:System.ArgumentException">if the address can't be resolved.</exception>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.Read(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadBoolean(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadByte(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadChar(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadDouble(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadDouble(Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadDouble(System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadFloat(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadFloat(Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadFloat(System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadInt(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadInt(Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadInt(System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadLong(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadLong(Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadLong(System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadShort(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadShort(Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataInput.ReadShort(System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteBoolean(System.Int32,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteByte(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteChar(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteDouble(System.Int32,System.Double)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteDouble(System.Double,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteDouble(System.Int32,System.Double,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteFloat(System.Int32,System.Single)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteFloat(System.Single,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteFloat(System.Int32,System.Single,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteInt(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteInt(System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteInt(System.Int32,System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteLong(System.Int32,System.Int64)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteLong(System.Int64,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteLong(System.Int32,System.Int64,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteShort(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteShort(System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IBufferObjectDataOutput.WriteShort(System.Int32,System.Int32,Hazelcast.Net.Ext.ByteOrder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Hazelcast.IO.IOUtil.CloseResource(System.IDisposable)">
            <summary>Closes the Closable quietly.</summary>
            <remarks>Closes the Closable quietly. So no exception will be thrown. Can also safely be called with a null value.</remarks>
            <param name="closeable">the Closeable to close.</param>
        </member>
        <member name="M:Hazelcast.IO.IMemberSocketInterceptor.OnAccept(System.Net.Sockets.Socket)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.IO.IObjectDataInput">
            <summary>Provides serialization methods for arrays of primitive types</summary>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.GetByteOrder">
            <returns>ByteOrder BIG_ENDIAN or LITTLE_ENDIAN</returns>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadBooleanArray">
            <returns>the boolean array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadByteArray">
            <returns>the byte array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadCharArray">
            <returns>the char array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadData">
            <returns>data read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadDoubleArray">
            <returns>double array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadFloatArray">
            <returns>float array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadIntArray">
            <returns>int array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadLongArray">
            <returns>long array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadObject``1">
            <returns>object array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadShortArray">
            <returns>short array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataInput.ReadUTFArray">
            <returns>String array read</returns>
            <exception cref="T:System.IO.IOException">
                if it reaches end of file before finish reading
            </exception>
        </member>
        <member name="T:Hazelcast.IO.IObjectDataOutput">
            <summary>Provides serialization methods for arrays by extending DataOutput</summary>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.GetByteOrder">
            <returns>ByteOrder BIG_ENDIAN or LITTLE_ENDIAN</returns>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.ToByteArray">
            <returns>copy of internal byte array</returns>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteBooleanArray(System.Boolean[])">
            <param name="booleans">boolean array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteByteArray(System.Byte[])">
            <param name="bytes">byte array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteCharArray(System.Char[])">
            <param name="chars">char array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteData(Hazelcast.IO.Serialization.IData)">
            <param name="data">data to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteDoubleArray(System.Double[])">
            <param name="values">double to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteFloatArray(System.Single[])">
            <param name="values">float to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteIntArray(System.Int32[])">
            <param name="ints">int array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteLongArray(System.Int64[])">
            <param name="longs">long array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteObject(System.Object)">
            <param name="object">object to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteShortArray(System.Int16[])">
            <param name="values">short to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.IObjectDataOutput.WriteUTFArray(System.String[])">
            <param name="values">string array to be written</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:Hazelcast.IO.ISocketInterceptor.OnConnect(System.Net.Sockets.Socket)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Hazelcast.Logging.AbstractLogger">
            <summary>
                Abstract
                <see cref="T:Hazelcast.Logging.ILogger">ILogger</see>
                implementation that provides implementations for the convenience methods like
                finest,info,warning and severe.
            </summary>
        </member>
        <member name="T:Hazelcast.Logging.ILogger">
            <summary>The Hazelcast logging interface.</summary>
            <remarks>
                The Hazelcast logging interface. The reason if its existence is that Hazelcast doesn't want any dependencies
                on concrete logging frameworks so it creates it own meta logging framework where existing logging frameworks can
                be placed behind.
            </remarks>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Finest(System.String)">
            <summary>
                Logs a message at
                <see cref="F:Hazelcast.Logging.LogLevel.Finest">LogLevel.Finest</see>
                .
            </summary>
            <param name="message">the message to log.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Finest(System.Exception)">
            <summary>
                Logs a throwable at
                <see cref="F:Hazelcast.Logging.LogLevel.Finest">LogLevel.Finest</see>
                .  The message of the Throwable will be the message.
            </summary>
            <param name="thrown">the Throwable to log.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Finest(System.String,System.Exception)">
            <summary>
                Logs message with associated throwable information at
                <see cref="F:Hazelcast.Logging.LogLevel.Finest">LogLevel.Finest</see>
                .
            </summary>
            <param name="message">the message to log</param>
            <param name="thrown">the Throwable associated to the message.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.GetLevel">
            <summary>Gets the logging Level.</summary>
            <remarks>Gets the logging Level.</remarks>
            <returns>the logging Level.</returns>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Info(System.String)">
            <summary>
                Logs a message at <see cref="F:Hazelcast.Logging.LogLevel.Info">LogLevel.Info</see>
                .
            </summary>
            <param name="message">the message to log.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.IsFinestEnabled">
            <summary>
                Checks if the
                <see cref="F:Hazelcast.Logging.LogLevel.Finest">LogLevel.Finest</see>
                is enabled.
            </summary>
            <returns>true if enabled, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.IsLoggable(Hazelcast.Logging.LogLevel)">
            <summary>Checks if a message at the provided level is going to be logged by this logger.</summary>
            <remarks>Checks if a message at the provided level is going to be logged by this logger.</remarks>
            <param name="level">the log level.</param>
            <returns>true if this Logger will log messages for the provided level, false otherwise.</returns>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Log(Hazelcast.Logging.LogLevel,System.String)">
            <summary>Logs a message at the provided Level.</summary>
            <remarks>Logs a message at the provided Level.</remarks>
            <param name="level">the Level of logging.</param>
            <param name="message">the message to log.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Log(Hazelcast.Logging.LogLevel,System.String,System.Exception)">
            <summary>Logs message with associated throwable information at the provided level.</summary>
            <remarks>Logs message with associated throwable information at the provided level.</remarks>
            <param name="level">The logging level of the message</param>
            <param name="message">the message to log</param>
            <param name="thrown">the Throwable associated to the message.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Severe(System.String)">
            <summary>
                Logs a message at
                <see cref="F:Hazelcast.Logging.LogLevel.Severe">LogLevel.Severe</see>
                .
            </summary>
            <param name="message">the message to log.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Severe(System.Exception)">
            <summary>
                Logs a throwable at
                <see cref="F:Hazelcast.Logging.LogLevel.Severe">LogLevel.Severe</see>
                .  The message of the Throwable will be the message.
            </summary>
            <param name="thrown">the Throwable to log.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Severe(System.String,System.Exception)">
            <summary>
                Logs message with associated throwable information at
                <see cref="F:Hazelcast.Logging.LogLevel.Severe">LogLevel.Severe</see>
                .
            </summary>
            <param name="message">the message to log</param>
            <param name="thrown">the Throwable associated to the message.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Warning(System.String)">
            <summary>
                Logs a message at
                <see cref="F:Hazelcast.Logging.LogLevel.Warning">LogLevel.Warning</see>
                .
            </summary>
            <param name="message">the message to log.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Warning(System.Exception)">
            <summary>
                Logs a throwable at
                <see cref="F:Hazelcast.Logging.LogLevel.Warning">LogLevel.Warning</see>
                .  The message of the Throwable will be the message.
            </summary>
            <param name="thrown">the Throwable to log.</param>
        </member>
        <member name="M:Hazelcast.Logging.ILogger.Warning(System.String,System.Exception)">
            <summary>
                Logs message with associated throwable information at
                <see cref="F:Hazelcast.Logging.LogLevel.Warning">LogLevel.Warning</see>
                .
            </summary>
            <param name="message">the message to log</param>
            <param name="thrown">the Throwable associated to the message.</param>
        </member>
        <member name="T:Hazelcast.Net.Ext.ByteOrder">
            <summary>
            Represent the endienness 
            </summary>
        </member>
        <member name="F:Hazelcast.Net.Ext.ByteOrder.BigEndian">
            <summary>
            Big Endian
            </summary>
        </member>
        <member name="F:Hazelcast.Net.Ext.ByteOrder.LittleEndian">
            <summary>
            Little endian
            </summary>
        </member>
        <member name="T:Hazelcast.Map.IEntryProcessor">
            <summary>
            A stateful serializable object which represents the EntryProcessor defined on server side.
            </summary>
            <remarks>
            This object must have a hazelcast serializable EntryProcessor counterpart registered on server side with the actual
            <c>org.hazelcast.map.EntryProcessor</c> implementation.
            Client side EntryProcessor does not have any processing logic.
            </remarks>
        </member>
        <member name="M:Hazelcast.Map.IMapInterceptor.AfterGet(System.Object)">
            <summary>Called after get(..) operation is completed.</summary>
            <remarks>
                Called after get(..) operation is completed.
                <p />
            </remarks>
            <param name="value">the value returned as the result of get(..) operation</param>
        </member>
        <member name="M:Hazelcast.Map.IMapInterceptor.AfterPut(System.Object)">
            <summary>Called after put(..) operation is completed.</summary>
            <remarks>
                Called after put(..) operation is completed.
                <p />
            </remarks>
            <param name="value">the value returned as the result of put(..) operation</param>
        </member>
        <member name="M:Hazelcast.Map.IMapInterceptor.AfterRemove(System.Object)">
            <summary>Called after remove(..) operation is completed.</summary>
            <remarks>
                Called after remove(..) operation is completed.
                <p />
            </remarks>
            <param name="value">the value returned as the result of remove(..) operation</param>
        </member>
        <member name="M:Hazelcast.Map.IMapInterceptor.InterceptGet(System.Object)">
            <summary>Intercept get operation before returning value.</summary>
            <remarks>
                Intercept get operation before returning value.
                Return another object to change the return value of get(..)
                Returning null will cause the get(..) operation return original value, namely return null if you do not want to
                change anything.
                <p />
            </remarks>
            <param name="value">the original value to be returned as the result of get(..) operation</param>
            <returns>the new value that will be returned by get(..) operation</returns>
        </member>
        <member name="M:Hazelcast.Map.IMapInterceptor.InterceptPut(System.Object,System.Object)">
            <summary>Intercept put operation before modifying map data.</summary>
            <remarks>
                Intercept put operation before modifying map data.
                Return the object to be put into the map.
                Returning null will cause the put(..) operation to operate as expected, namely no interception.
                Throwing an exception will cancel the put operation.
                <p />
            </remarks>
            <param name="oldValue">the value currently in map</param>
            <param name="newValue">the new value to be put</param>
            <returns>new value after intercept operation</returns>
        </member>
        <member name="M:Hazelcast.Map.IMapInterceptor.InterceptRemove(System.Object)">
            <summary>Intercept remove operation before removing the data.</summary>
            <remarks>
                Intercept remove operation before removing the data.
                Return the object to be returned as the result of remove operation.
                Throwing an exception will cancel the remove operation.
                <p />
            </remarks>
            <param name="removedValue">the existing value to be removed</param>
            <returns>the value to be returned as the result of remove operation</returns>
        </member>
        <member name="T:Hazelcast.Security.AbstractCredentials">
            <summary>
                Abstract implementation of
                <see cref="T:Hazelcast.Security.ICredentials">ICredentials</see>
            </summary>
        </member>
        <member name="T:Hazelcast.Security.ICredentials">
            <summary>
                ICredentials is a container object for endpoint (Members and Clients)
                security attributes.
            </summary>
            <remarks>
                ICredentials is a container object for endpoint (Members and Clients)
                security attributes.
                <p />
                It is used on authentication process by
            </remarks>
        </member>
        <member name="M:Hazelcast.Security.ICredentials.GetEndpoint">
            <summary>Returns IP address of endpoint.</summary>
            <remarks>Returns IP address of endpoint.</remarks>
            <returns>endpoint address</returns>
        </member>
        <member name="M:Hazelcast.Security.ICredentials.GetPrincipal">
            <summary>Returns principal of endpoint.</summary>
            <remarks>Returns principal of endpoint.</remarks>
            <returns>endpoint principal</returns>
        </member>
        <member name="M:Hazelcast.Security.ICredentials.SetEndpoint(System.String)">
            <summary>Sets IP address of endpoint.</summary>
            <remarks>Sets IP address of endpoint.</remarks>
            <param name="endpoint">address</param>
        </member>
        <member name="T:Hazelcast.Security.UsernamePasswordCredentials">
            <summary>
                Simple implementation of
                <see cref="T:Hazelcast.Security.ICredentials">ICredentials</see>
                using
                username and password as security attributes.
            </summary>
        </member>
        <member name="T:Hazelcast.Transaction.ITransactionalObject">
            <summary>Marker interface for all transactional distributed objects.</summary>
            <remarks>Marker interface for all transactional distributed objects.</remarks>
        </member>
        <member name="T:Hazelcast.Transaction.ITransactionalTaskContext">
            <summary>
                Provides a context to access transactional data-structures like the
                <see cref="T:Hazelcast.Core.ITransactionalMap`2">Hazelcast.Core.ITransactionalMap&lt;K, V&gt;</see>
                .
            </summary>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionalTaskContext.GetList``1(System.String)">
            <summary>Returns the transactional list instance with the specified name.</summary>
            <remarks>Returns the transactional list instance with the specified name.</remarks>
            <param name="name">name of the list</param>
            <returns>transactional list instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionalTaskContext.GetMap``2(System.String)">
            <summary>Returns the transactional distributed map instance with the specified name.</summary>
            <remarks>Returns the transactional distributed map instance with the specified name.</remarks>
            <param name="name">name of the distributed map</param>
            <returns>transactional distributed map instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionalTaskContext.GetMultiMap``2(System.String)">
            <summary>Returns the transactional multimap instance with the specified name.</summary>
            <remarks>Returns the transactional multimap instance with the specified name.</remarks>
            <param name="name">name of the multimap</param>
            <returns>transactional multimap instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionalTaskContext.GetQueue``1(System.String)">
            <summary>Returns the transactional queue instance with the specified name.</summary>
            <remarks>Returns the transactional queue instance with the specified name.</remarks>
            <param name="name">name of the queue</param>
            <returns>transactional queue instance with the specified name</returns>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionalTaskContext.GetSet``1(System.String)">
            <summary>Returns the transactional set instance with the specified name.</summary>
            <remarks>Returns the transactional set instance with the specified name.</remarks>
            <param name="name">name of the set</param>
            <returns>transactional set instance with the specified name</returns>
        </member>
        <member name="T:Hazelcast.Transaction.ITransactionContext">
            <summary>
                Provides a context to do transactional operations; so beginning/committing transactions, but also retrieving
                transactional data-structures like the
                <see cref="T:Hazelcast.Core.ITransactionalMap`2">Hazelcast.Core.ITransactionalMap&lt;K, V&gt;</see>
                .
            </summary>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionContext.BeginTransaction">
            <summary>Begins a transaction.</summary>
            <remarks>Begins a transaction.</remarks>
            <exception cref="T:System.InvalidOperationException">if a transaction already is active.</exception>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionContext.CommitTransaction">
            <summary>Commits a transaction.</summary>
            <remarks>Commits a transaction.</remarks>
            <exception cref="T:Hazelcast.Transaction.TransactionException">if no transaction is active or the transaction could not be committed.</exception>
            <exception cref="T:Hazelcast.Transaction.TransactionException"></exception>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionContext.GetTxnId">
            <summary>Gets the id that uniquely identifies the transaction.</summary>
            <remarks>Gets the id that uniquely identifies the transaction.</remarks>
            <returns>the transaction id.</returns>
        </member>
        <member name="M:Hazelcast.Transaction.ITransactionContext.RollbackTransaction">
            <summary>Rollback of the current transaction.</summary>
            <remarks>Rollback of the current transaction.</remarks>
            <exception cref="T:System.InvalidOperationException">if no there is no active transaction.</exception>
        </member>
        <member name="T:Hazelcast.Transaction.TransactionException">
            <summary>
                A
                <see cref="T:Hazelcast.Core.HazelcastException">Hazelcast.Core.HazelcastException</see>
                that is thrown when something goes wrong while dealing with transactions and transactional
                data-structures.
            </summary>
        </member>
        <member name="T:Hazelcast.Transaction.TransactionNotActiveException">
            <summary>
                A
                <see cref="T:Hazelcast.Core.HazelcastException">Hazelcast.Core.HazelcastException</see>
                thrown when an a transactional operation is executed without an active transaction.
            </summary>
        </member>
        <member name="T:Hazelcast.Transaction.TransactionOptions">
            <summary>Contains the configuration for a transaction</summary>
        </member>
        <member name="F:Hazelcast.Transaction.TransactionOptions.TransactionType.TwoPhase">
            <summary>The two phase commit is separated in 2 parts.</summary>
            <remarks>
            The two phase commit is separated in 2 parts. First it tries to execute the prepare; if there are any conflicts,
            the prepare will fail. Once the prepare has succeeded, the commit (writing the changes) can be executed.
            Hazelcast also provides three phase transaction by automatically copying the backlog to another member so that in case
            of failure during a commit, another member can continue the commit from backup. For more information see the
            <see cref="M:Hazelcast.Transaction.TransactionOptions.SetDurability(System.Int32)"/>
            </remarks>
        </member>
        <member name="F:Hazelcast.Transaction.TransactionOptions.TransactionType.OnePhase">
            <summary>The one phase transaction executes a transaction using a single step at the end; committing the changes.</summary>
            <remarks>
            The one phase transaction executes a transaction using a single step at the end; committing the changes. There
            is no prepare of the transactions, so conflicts are not detected. If there is a conflict, then when the transaction
            commits the changes, some of the changes are written and others are not; leaving the system in a potentially permanent
            inconsistent state.
            </remarks>
        </member>
        <member name="M:Hazelcast.Transaction.TransactionOptions.#ctor">
            <summary>Creates a new default configured TransactionsOptions.</summary>
            <remarks>
                Creates a new default configured TransactionsOptions.
                It will be configured with a timeout of 2 minutes, durability of 1 and a TransactionType.TWO_PHASE.
            </remarks>
        </member>
        <member name="M:Hazelcast.Transaction.TransactionOptions.GetDefault">
            <summary>Creates a new TransactionOptions configured with default settings.</summary>
            <remarks>Creates a new TransactionOptions configured with default settings.</remarks>
            <returns>the created default TransactionOptions.</returns>
            <seealso cref="M:Hazelcast.Transaction.TransactionOptions.#ctor">TransactionOptions()</seealso>
        </member>
        <member name="M:Hazelcast.Transaction.TransactionOptions.GetDurability">
            <summary>Gets the transaction durability.</summary>
            <remarks>Gets the transaction durability.</remarks>
            <returns>the transaction durability.</returns>
            <seealso cref="M:Hazelcast.Transaction.TransactionOptions.SetDurability(System.Int32)">SetDurability(int)</seealso>
        </member>
        <member name="M:Hazelcast.Transaction.TransactionOptions.GetTimeoutMillis">
            <summary>Gets the timeout in milliseconds.</summary>
            <remarks>Gets the timeout in milliseconds.</remarks>
            <returns>the timeout in milliseconds.</returns>
            <seealso cref="M:Hazelcast.Transaction.TransactionOptions.SetTimeout(System.Int64,Hazelcast.Core.TimeUnit)">SetTimeout(long, TimeUnit)</seealso>
        </member>
        <member name="M:Hazelcast.Transaction.TransactionOptions.GetTransactionType">
            <summary>
                Gets the
                <see cref="T:Hazelcast.Transaction.TransactionOptions.TransactionType">TransactionType</see>
                .
            </summary>
            <returns>the TransactionType.</returns>
        </member>
        <member name="M:Hazelcast.Transaction.TransactionOptions.SetDurability(System.Int32)">
            <summary>Sets the transaction durability.</summary>
            <remarks>
                Sets the transaction durability.
                The durability is the number of machines that can take over if a member fails during a transaction
                commit or rollback. This value only has meaning when
                <see cref="F:Hazelcast.Transaction.TransactionOptions.TransactionType.TwoPhase">TransactionType.TwoPhase</see>
                is selected.
            </remarks>
            <param name="durability">the durability</param>
            <returns>the updated TransactionOptions.</returns>
            <exception cref="T:System.ArgumentException">if durability smaller than 0.</exception>
        </member>
        <member name="M:Hazelcast.Transaction.TransactionOptions.SetTimeout(System.Int64,Hazelcast.Core.TimeUnit)">
            <summary>Sets the timeout.</summary>
            <remarks>
                Sets the timeout.
                The timeout determines the maximum lifespan of a transaction. So if a transaction is configured with a
                timeout of 2 minutes, then it will automatically rollback if it hasn't committed yet.
            </remarks>
            <param name="timeout">the timeout.</param>
            <param name="timeUnit">the TimeUnit of the timeout.</param>
            <returns>the updated TransactionOptions</returns>
            <exception cref="T:System.ArgumentException">if timeout smaller or equal than 0, or timeUnit is null.</exception>
            <seealso cref="M:Hazelcast.Transaction.TransactionOptions.GetTimeoutMillis">GetTimeoutMillis()</seealso>
        </member>
        <member name="M:Hazelcast.Transaction.TransactionOptions.SetTransactionType(Hazelcast.Transaction.TransactionOptions.TransactionType)">
            <summary>
                Sets the
                <see cref="T:Hazelcast.Transaction.TransactionOptions.TransactionType">TransactionType</see>
                .
                A local transaction is less safe than a two phase transaction; when a member fails during the commit
                of a local transaction, it could be that some of the changes are committed, while others are not and this
                can leave your system in an inconsistent state.
            </summary>
            <param name="transactionType">the new TransactionType.</param>
            <returns>the updated TransactionOptions.</returns>
            <seealso cref="M:Hazelcast.Transaction.TransactionOptions.GetTransactionType">GetTransactionType()</seealso>
            <seealso cref="M:Hazelcast.Transaction.TransactionOptions.SetDurability(System.Int32)">SetDurability(int)</seealso>
        </member>
        <member name="M:Hazelcast.Util.HashUtil.MurmurHash3_x86_32(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Returns the MurmurHash3_x86_32 hash.</summary>
        </member>
        <member name="T:Hazelcast.Util.IterationType">
            <summary>
            To differentiate users selection on result collection on map-wide operations like values , keySet , query etc.
            </summary>
        </member>
        <member name="F:Hazelcast.Util.IterationType.Key">
            <summary>
            Iterate over keys
            </summary>
        </member>
        <member name="F:Hazelcast.Util.IterationType.Value">
            <summary>
            Iterate over values
            </summary>
        </member>
        <member name="F:Hazelcast.Util.IterationType.Entry">
            <summary>
            Iterate over whole entry (so key and value)
            </summary>
        </member>
        <member name="T:Hazelcast.Util.QuickMath">
            <summary>
            The class
            <code>QuickMath</code>
            contains methods to perform optimized mathematical operations.
            Methods are allowed to put additional constraints on the range of input values if required for efficiency.
            Methods are <b>not</b> required to perform validation of input arguments, but they have to indicate the constraints
            in theirs contract.
            </summary>
        </member>
        <member name="M:Hazelcast.Util.QuickMath.IsPowerOfTwo(System.Int64)">
            <summary>Return true if input argument is power of two.</summary>
            <remarks>
            Return true if input argument is power of two.
            Input has to be a a positive integer.
            Result is undefined for zero or negative integers.
            </remarks>
            <param name="x"></param>
            <returns><code>true</code> if <code>x</code> is power of two</returns>
        </member>
        <member name="T:Hazelcast.Util.RandomLB">
            <summary>The RandomLB randomly selects a member to route to.</summary>
            <remarks>The RandomLB randomly selects a member to route to.</remarks>
        </member>
        <member name="P:Hazelcast.Util.StripedTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level supported by this scheduler.</summary>
        </member>
        <member name="M:Hazelcast.Util.StripedTaskScheduler.Dispose">
            <summary>
                Cleans up the scheduler by indicating that no more tasks will be queued.
                This method blocks until all threads successfully shutdown.
            </summary>
        </member>
        <member name="M:Hazelcast.Util.StripedTaskScheduler.GetScheduledTasks">
            <summary>Provides a list of the scheduled tasks for the debugger to consume.</summary>
            <returns>An enumerable of all tasks currently scheduled.</returns>
        </member>
        <member name="M:Hazelcast.Util.StripedTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a Task to be executed by this scheduler.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:Hazelcast.Util.StripedTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Determines whether a Task may be inlined.</summary>
            <param name="task">The task to be executed.</param>
            <param name="taskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was successfully inlined; otherwise, false.</returns>
        </member>
        <member name="T:Hazelcast.Util.ValidationUtil">
            <summary>A utility class for validating arguments and state.</summary>
            <remarks>A utility class for validating arguments and state.</remarks>
        </member>
        <member name="T:Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Properties.Resources.hazelcast_client_default">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
            &lt;!--
              ~ Copyright (c) 2008-2013, Hazelcast, Inc. All Rights Reserved.
              ~
              ~ Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
              ~ you may not use this file except in compliance with the License.
              ~ You may obtain a copy of the License at
              ~
              ~ http://www.apache.org/licenses/LICENSE-2.0
              ~
              ~ Unless required by applicable law or agreed to in writing, software
              ~ distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
              ~ WITHOUT WARRANTI [rest of string was truncated]&quot;;.
             </summary>
        </member>
    </members>
</doc>
